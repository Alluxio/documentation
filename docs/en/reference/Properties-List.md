# List of Configuration Properties


All Alluxio configuration settings fall into one of the six categories:
[Common](#common-configuration) (shared by Master and Worker),
[Master specific](#master-configuration), [Worker specific](#worker-configuration),
[User specific](#user-configuration), [Cluster specific](#resource-manager-configuration) (used for running
Alluxio with cluster managers like Mesos and YARN), and
[Security specific](#security-configuration) (shared by Master, Worker, and User).

## Common Configuration

The common configuration contains constants shared by different components.

<table class="table table-striped">
<tbody><tr><th>Property Name</th><th>Default</th><th>Description</th></tr>
<tr>  <td><a class="anchor" name="alluxio.conf.dynamic.update.enabled"></a> alluxio.conf.dynamic.update.enabled</td>  <td>false</td>  <td>Whether to support dynamic update property.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.debug"></a> alluxio.debug</td>  <td>false</td>  <td>Set to true to enable debug mode which has additional logging and info in the Web UI.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.exit.collect.info"></a> alluxio.exit.collect.info</td>  <td>true</td>  <td>If true, the process will dump metrics and jstack into the log folder. This only applies to Alluxio master and worker processes.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.auth.policy.class"></a> alluxio.fuse.auth.policy.class</td>  <td>alluxio.fuse.auth.LaunchUserGroupAuthPolicy</td>  <td>The fuse auth policy class.  Valid options include: `alluxio.fuse.auth.LaunchUserGroupAuthPolicy` using the user launching the AlluxioFuse application to do authentication, `alluxio.fuse.auth.SystemUserGroupAuthPolicy` using the end-user running the fuse command to do authentication which matches POSIX standard but sacrifices performance, `alluxio.fuse.auth.CustomAuthPolicy` using the custom user group to do authentication.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.auth.policy.custom.group"></a> alluxio.fuse.auth.policy.custom.group</td>  <td></td>  <td>The fuse group name for custom auth policy. Only valid if the alluxio.fuse.auth.policy.class is alluxio.fuse.auth.CustomAuthPolicy</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.auth.policy.custom.user"></a> alluxio.fuse.auth.policy.custom.user</td>  <td></td>  <td>The fuse user name for custom auth policy. Only valid if the alluxio.fuse.auth.policy.class is alluxio.fuse.auth.CustomAuthPolicy</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.cached.paths.max"></a> alluxio.fuse.cached.paths.max</td>  <td>500</td>  <td>Maximum number of FUSE-to-Alluxio path mappings to cache for FUSE conversion.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.debug.enabled"></a> alluxio.fuse.debug.enabled</td>  <td>false</td>  <td>Run FUSE in debug mode, and have the fuse process log every FS request.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.fs.name"></a> alluxio.fuse.fs.name</td>  <td>alluxio-fuse</td>  <td>The FUSE file system name.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.jnifuse.enabled"></a> alluxio.fuse.jnifuse.enabled</td>  <td>true</td>  <td>Use JNI-Fuse library for better performance. If disabled, JNR-Fuse will be used.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.jnifuse.libfuse.version"></a> alluxio.fuse.jnifuse.libfuse.version</td>  <td>2</td>  <td>The version of libfuse used by libjnifuse. Libfuse2 and Libfuse3 are supported.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.logging.threshold"></a> alluxio.fuse.logging.threshold</td>  <td>10s</td>  <td>Logging a FUSE API call when it takes more time than the threshold.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.mount.alluxio.path"></a> alluxio.fuse.mount.alluxio.path</td>  <td>/</td>  <td>The Alluxio path to mount to the given Fuse mount point configured by alluxio.fuse.mount.point in the worker when alluxio.worker.fuse.enabled is enabled or in the standalone Fuse process.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.mount.options"></a> alluxio.fuse.mount.options</td>  <td>attr_timeout=600,entry_timeout=600</td>  <td>The platform specific Fuse mount options to mount the given Fuse mount point. If multiple mount options are provided, separate them with comma.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.mount.point"></a> alluxio.fuse.mount.point</td>  <td>/mnt/alluxio-fuse</td>  <td>The absolute local filesystem path that worker (if alluxio.worker.fuse.enabled is enabled)or standalone Fuse will mount Alluxio path to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.shared.caching.reader.enabled"></a> alluxio.fuse.shared.caching.reader.enabled</td>  <td>false</td>  <td>(Experimental) Use share grpc data reader for better performance on multi-process file reading through Alluxio JNI Fuse. Blocks data will be cached on the client side so more memory is required for the Fuse process.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.special.command.enabled"></a> alluxio.fuse.special.command.enabled</td>  <td>false</td>  <td>If enabled, user can issue special FUSE commands by using 'ls -l /path/to/fuse_mount/.alluxiocli.&lt;command_name&gt;.&lt;subcommand_name&gt;', For example, when the Alluxio is mounted at local path /mnt/alluxio-fuse, 'ls -l /mnt/alluxio-fuse/.alluxiocli.metadatacache.dropAll' will drop all the user metadata cache. 'ls -l /mnt/alluxio-fuse/.alluxiocli.metadatacache.size' will get the metadata cache sizeï¼Œ the size value will be show in the output's filesize field. 'ls -l /mnt/alluxio-fuse/path/to/be/cleaned/.alluxiocli.metadatacache.drop' will drop the metadata cache of path '/mnt/alluxio-fuse/path/to/be/cleaned/'</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.stat.cache.refresh.interval"></a> alluxio.fuse.stat.cache.refresh.interval</td>  <td>5min</td>  <td>The fuse filesystem statistics (e.g. Alluxio capacity information) will be refreshed after being cached for this time period. If the refresh time is too big, operations on the FUSE may fail because of the stale filesystem statistics. If it is too small, continuously fetching filesystem statistics create a large amount of master RPC calls and lower the overall performance of the Fuse application. A value small than or equal to zero means no statistics cache on the Fuse side.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.umount.timeout"></a> alluxio.fuse.umount.timeout</td>  <td>0s</td>  <td>The timeout to wait for all in progress file read and write to finish before unmounting the Fuse filesystem when SIGTERM signal is received. A value smaller than or equal to zero means no umount wait time. </td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.user.group.translation.enabled"></a> alluxio.fuse.user.group.translation.enabled</td>  <td>false</td>  <td>Whether to translate Alluxio users and groups into Unix users and groups when exposing Alluxio files through the FUSE API. When this property is set to false, the user and group for all FUSE files will match the user who started the alluxio-fuse process.Note that this applies to JNR-FUSE only.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.web.bind.host"></a> alluxio.fuse.web.bind.host</td>  <td>0.0.0.0</td>  <td>The hostname Alluxio FUSE web UI binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.web.enabled"></a> alluxio.fuse.web.enabled</td>  <td>false</td>  <td>Whether to enable FUSE web server.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.web.hostname"></a> alluxio.fuse.web.hostname</td>  <td></td>  <td>The hostname of Alluxio FUSE web UI.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.fuse.web.port"></a> alluxio.fuse.web.port</td>  <td>49999</td>  <td>The port Alluxio FUSE web UI runs on.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.grpc.reflection.enabled"></a> alluxio.grpc.reflection.enabled</td>  <td>false</td>  <td>If true, grpc reflection will be enabled on alluxio grpc servers, including masters, workers, job masters and job workers.  This makes grpc tools such as grpcurl or grpcui can send grpc requests to the master server easier without knowing the protobufs. This is a debug option.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.hadoop.kerberos.keytab.login.autorenewal"></a> alluxio.hadoop.kerberos.keytab.login.autorenewal</td>  <td></td>  <td>Kerberos authentication keytab login auto renew.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.hadoop.security.authentication"></a> alluxio.hadoop.security.authentication</td>  <td></td>  <td>HDFS authentication method.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.hadoop.security.krb5.conf"></a> alluxio.hadoop.security.krb5.conf</td>  <td></td>  <td>Kerberos krb file for configuration of Kerberos.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.home"></a> alluxio.home</td>  <td>/opt/alluxio</td>  <td>Alluxio installation directory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.batch.size"></a> alluxio.job.batch.size</td>  <td>20</td>  <td>The number of tasks would be included in a job request.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.bind.host"></a> alluxio.job.master.bind.host</td>  <td>0.0.0.0</td>  <td>The host that the Alluxio job master will bind to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.client.threads"></a> alluxio.job.master.client.threads</td>  <td>1024</td>  <td>The number of threads the Alluxio master uses to make requests to the job master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.embedded.journal.addresses"></a> alluxio.job.master.embedded.journal.addresses</td>  <td></td>  <td>A comma-separated list of journal addresses for all job masters in the cluster. The format is 'hostname1:port1,hostname2:port2,...'. Defaults to the journal addresses set for the Alluxio masters (alluxio.master.embedded.journal.addresses), but with the job master embedded journal port.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.embedded.journal.port"></a> alluxio.job.master.embedded.journal.port</td>  <td>20003</td>  <td>The port job masters use for embedded journal communications.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.finished.job.purge.count"></a> alluxio.job.master.finished.job.purge.count</td>  <td>-1</td>  <td>The maximum amount of jobs to purge at any single time when the job master reaches its maximum capacity. It is recommended to set this value when setting the capacity of the job master to a large ( &gt; 10M) value. Default is -1 denoting an unlimited value</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.finished.job.retention.time"></a> alluxio.job.master.finished.job.retention.time</td>  <td>60sec</td>  <td>The length of time the Alluxio Job Master should save information about completed jobs before they are discarded.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.hostname"></a> alluxio.job.master.hostname</td>  <td>${alluxio.master.hostname}</td>  <td>The hostname of the Alluxio job master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.job.capacity"></a> alluxio.job.master.job.capacity</td>  <td>100000</td>  <td>The total possible number of available job statuses in the job master. This value includes running and finished jobs which are have completed within alluxio.job.master.finished.job.retention.time.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.lost.worker.interval"></a> alluxio.job.master.lost.worker.interval</td>  <td>1sec</td>  <td>The time interval the job master waits between checks for lost workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.network.flowcontrol.window"></a> alluxio.job.master.network.flowcontrol.window</td>  <td>2MB</td>  <td>The HTTP2 flow control window used by Alluxio job-master gRPC connections. Larger value will allow more data to be buffered but will use more memory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.network.keepalive.time"></a> alluxio.job.master.network.keepalive.time</td>  <td>2h</td>  <td>The amount of time for Alluxio job-master gRPC server to wait for a response before pinging the client to see if it is still alive.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.network.keepalive.timeout"></a> alluxio.job.master.network.keepalive.timeout</td>  <td>30sec</td>  <td>The maximum time for Alluxio job-master gRPC server to wait for a keepalive response before closing the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.network.max.inbound.message.size"></a> alluxio.job.master.network.max.inbound.message.size</td>  <td>100MB</td>  <td>The maximum size of a message that can be sent to the Alluxio master</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.network.permit.keepalive.time"></a> alluxio.job.master.network.permit.keepalive.time</td>  <td>30sec</td>  <td>Specify the most aggressive keep-alive time clients are permitted to configure. The server will try to detect clients exceeding this rate and when detected will forcefully close the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.rpc.addresses"></a> alluxio.job.master.rpc.addresses</td>  <td></td>  <td>A list of comma-separated host:port RPC addresses where the client should look for job masters when using multiple job masters without Zookeeper. This property is not used when Zookeeper is enabled, since Zookeeper already stores the job master addresses. If property is not defined, clients will look for job masters using [alluxio.master.rpc.addresses]:alluxio.job.master.rpc.port first, then for [alluxio.job.master.embedded.journal.addresses]:alluxio.job.master.rpc.port.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.rpc.port"></a> alluxio.job.master.rpc.port</td>  <td>20001</td>  <td>The port for Alluxio job master's RPC service.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.web.bind.host"></a> alluxio.job.master.web.bind.host</td>  <td>0.0.0.0</td>  <td>The host that the job master web server binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.web.hostname"></a> alluxio.job.master.web.hostname</td>  <td>${alluxio.job.master.hostname}</td>  <td>The hostname of the job master web server.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.web.port"></a> alluxio.job.master.web.port</td>  <td>20002</td>  <td>The port the job master web server uses.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.worker.heartbeat.interval"></a> alluxio.job.master.worker.heartbeat.interval</td>  <td>1sec</td>  <td>The amount of time that the Alluxio job worker should wait in between heartbeats to the Job Master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.master.worker.timeout"></a> alluxio.job.master.worker.timeout</td>  <td>60sec</td>  <td>The time period after which the job master will mark a worker as lost without a subsequent heartbeat.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.request.batch.size"></a> alluxio.job.request.batch.size</td>  <td>1</td>  <td>The batch size client uses to make requests to the job master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.retention.time"></a> alluxio.job.retention.time</td>  <td>1d</td>  <td>The length of time the Alluxio should save information about completed jobs before they are discarded.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.worker.bind.host"></a> alluxio.job.worker.bind.host</td>  <td>0.0.0.0</td>  <td>The host that the Alluxio job worker will bind to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.worker.data.port"></a> alluxio.job.worker.data.port</td>  <td>30002</td>  <td>The port the Alluxio Job worker uses to send data.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.worker.hostname"></a> alluxio.job.worker.hostname</td>  <td>${alluxio.worker.hostname}</td>  <td>The hostname of the Alluxio job worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.worker.rpc.port"></a> alluxio.job.worker.rpc.port</td>  <td>30001</td>  <td>The port for Alluxio job worker's RPC service.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.worker.threadpool.size"></a> alluxio.job.worker.threadpool.size</td>  <td>10</td>  <td>Number of threads in the thread pool for job worker. This may be adjusted to a lower value to alleviate resource saturation on the job worker nodes (CPU + IO).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.worker.throttling"></a> alluxio.job.worker.throttling</td>  <td>false</td>  <td>Whether the job worker should throttle itself based on whether the resources are saturated.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.worker.web.bind.host"></a> alluxio.job.worker.web.bind.host</td>  <td>0.0.0.0</td>  <td>The host the job worker web server binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.job.worker.web.port"></a> alluxio.job.worker.web.port</td>  <td>30003</td>  <td>The port the Alluxio job worker web server uses.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.jvm.monitor.info.threshold"></a> alluxio.jvm.monitor.info.threshold</td>  <td>1sec</td>  <td>When the JVM pauses for anything longer than this, log an INFO message.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.jvm.monitor.sleep.interval"></a> alluxio.jvm.monitor.sleep.interval</td>  <td>1sec</td>  <td>The time for the JVM monitor thread to sleep.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.jvm.monitor.warn.threshold"></a> alluxio.jvm.monitor.warn.threshold</td>  <td>10sec</td>  <td>When the JVM pauses for anything longer than this, log a WARN message.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.leak.detector.exit.on.leak"></a> alluxio.leak.detector.exit.on.leak</td>  <td>false</td>  <td>If set to true, the JVM will exit as soon as a leak is detected. Use only in testing environments.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.leak.detector.level"></a> alluxio.leak.detector.level</td>  <td>DISABLED</td>  <td>Set this to one of {DISABLED, SIMPLE, ADVANCED, PARANOID} to track resource leaks in the Alluxio codebase. DISABLED does not track any leaks. SIMPLE only samples resources, and doesn't track recent accesses, having a low overhead. ADVANCED is like simple, but tracks recent object accesses and has higher overhead. PARANOID tracks all objects and has the highest overhead. It is recommended to only use this value during testing.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.locality.compare.node.ip"></a> alluxio.locality.compare.node.ip</td>  <td>false</td>  <td>Whether try to resolve the node IP address for locality checking</td></tr>
<tr>  <td><a class="anchor" name="alluxio.logserver.hostname"></a> alluxio.logserver.hostname</td>  <td></td>  <td>The hostname of Alluxio logserver. Note: overwriting this property will only work when it is passed as a JVM system property (e.g., appending "-Dalluxio.logserver.hostname"=&lt;NEW_VALUE&gt;" to $ALLUXIO_JAVA_OPTS). Setting it in alluxio-site.properties will not work.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.logserver.logs.dir"></a> alluxio.logserver.logs.dir</td>  <td>${alluxio.work.dir}/logs</td>  <td>Default location for remote log files. Note: overwriting this property will only work when it is passed as a JVM system property (e.g., appending "-Dalluxio.logserver.logs.dir"=&lt;NEW_VALUE&gt;" to $ALLUXIO_JAVA_OPTS). Setting it in alluxio-site.properties will not work.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.logserver.port"></a> alluxio.logserver.port</td>  <td>45600</td>  <td>Default port of logserver to receive logs from alluxio servers. Note: overwriting this property will only work when it is passed as a JVM system property (e.g., appending "-Dalluxio.logserver.port"=&lt;NEW_VALUE&gt;" to $ALLUXIO_JAVA_OPTS). Setting it in alluxio-site.properties will not work.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.logserver.threads.max"></a> alluxio.logserver.threads.max</td>  <td>2048</td>  <td>The maximum number of threads used by logserver to service logging requests.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.logserver.threads.min"></a> alluxio.logserver.threads.min</td>  <td>512</td>  <td>The minimum number of threads used by logserver to service logging requests.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.metrics.conf.file"></a> alluxio.metrics.conf.file</td>  <td>${alluxio.conf.dir}/metrics.properties</td>  <td>The file path of the metrics system configuration file. By default it is `metrics.properties` in the `conf` directory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.metrics.executor.task.warn.frequency"></a> alluxio.metrics.executor.task.warn.frequency</td>  <td>5sec</td>  <td>When instrumenting an executor withInstrumentedExecutorService, if the number of active tasks (queued or running) is greater than alluxio.metrics.executor.task.warn.size value, a warning log will be printed at the given interval</td></tr>
<tr>  <td><a class="anchor" name="alluxio.metrics.executor.task.warn.size"></a> alluxio.metrics.executor.task.warn.size</td>  <td>1000</td>  <td>When instrumenting an executor with InstrumentedExecutorService, if the number of active tasks (queued or running) is greater than this value, a warning log will be printed at the interval given by alluxio.metrics.executor.task.warn.frequency</td></tr>
<tr>  <td><a class="anchor" name="alluxio.network.connection.auth.timeout"></a> alluxio.network.connection.auth.timeout</td>  <td>30sec</td>  <td>Maximum time to wait for a connection (gRPC channel) to attempt to receive an authentication response.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.network.connection.health.check.timeout"></a> alluxio.network.connection.health.check.timeout</td>  <td>5sec</td>  <td>Allowed duration for checking health of client connections (gRPC channels) before being assigned to a client. If a connection does not become active  within configured time, it will be shut down and a new connection will be created for the client</td></tr>
<tr>  <td><a class="anchor" name="alluxio.network.connection.server.shutdown.timeout"></a> alluxio.network.connection.server.shutdown.timeout</td>  <td>60sec</td>  <td>Maximum time to wait for gRPC server to stop on shutdown</td></tr>
<tr>  <td><a class="anchor" name="alluxio.network.connection.shutdown.graceful.timeout"></a> alluxio.network.connection.shutdown.graceful.timeout</td>  <td>45sec</td>  <td>Maximum time to wait for connections (gRPC channels) to stop on shutdown</td></tr>
<tr>  <td><a class="anchor" name="alluxio.network.connection.shutdown.timeout"></a> alluxio.network.connection.shutdown.timeout</td>  <td>15sec</td>  <td>Maximum time to wait for connections (gRPC channels) to stop after graceful shutdown attempt.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.network.host.resolution.timeout"></a> alluxio.network.host.resolution.timeout</td>  <td>5sec</td>  <td>During startup of the Master and Worker processes Alluxio needs to ensure that they are listening on externally resolvable and reachable host names. To do this, Alluxio will automatically attempt to select an appropriate host name if one was not explicitly specified. This represents the maximum amount of time spent waiting to determine if a candidate host name is resolvable over the network.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.network.ip.address.used"></a> alluxio.network.ip.address.used</td>  <td>false</td>  <td>If true, when alluxio.&lt;service_name&gt;.hostname and alluxio.&lt;service_name&gt;.bind.host of a service not specified, use IP as the connect host of the service.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.audit.logging.enabled"></a> alluxio.proxy.audit.logging.enabled</td>  <td>false</td>  <td>Set to true to enable proxy audit.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.bucket.naming.restrictions.enabled"></a> alluxio.proxy.s3.bucket.naming.restrictions.enabled</td>  <td>false</td>  <td>Toggles whether or not the Alluxio S3 API will enforce AWS S3 bucket naming restrictions. See https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.bucketpathcache.timeout"></a> alluxio.proxy.s3.bucketpathcache.timeout</td>  <td>0min</td>  <td>Expire bucket path statistics in cache for this time period. Set 0min to disable the cache. If enabling the cache, be careful that Alluxio S3 API will behave differently from AWS S3 API if bucket path cache entries become stale.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.complete.multipart.upload.keepalive.enabled"></a> alluxio.proxy.s3.complete.multipart.upload.keepalive.enabled</td>  <td>false</td>  <td>Whether or not to enabled sending whitespace characters as a keepalive message during CompleteMultipartUpload. Enabling this will cause any errors to be silently ignored. However, the errors will appear in the Proxy logs.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.complete.multipart.upload.keepalive.time.interval"></a> alluxio.proxy.s3.complete.multipart.upload.keepalive.time.interval</td>  <td>30sec</td>  <td>The complete multipart upload maximum keepalive time. The keepalive whitespace characters will be sent after 1 second, exponentially increasing in duration up to the configured value.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.complete.multipart.upload.min.part.size"></a> alluxio.proxy.s3.complete.multipart.upload.min.part.size</td>  <td>5MB</td>  <td>The minimum required file size of parts for multipart uploads. Parts which are smaller than this limit aside from the final part will result in an EntityTooSmall error code. Set to 0 to disable size requirements.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.complete.multipart.upload.pool.size"></a> alluxio.proxy.s3.complete.multipart.upload.pool.size</td>  <td>20</td>  <td>The complete multipart upload thread pool size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.deletetype"></a> alluxio.proxy.s3.deletetype</td>  <td>ALLUXIO_AND_UFS</td>  <td>Delete type when deleting buckets and objects through S3 API. Valid options are `ALLUXIO_AND_UFS` (delete both in Alluxio and UFS), `ALLUXIO_ONLY` (delete only the buckets or objects in Alluxio namespace).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.global.read.rate.limit.mb"></a> alluxio.proxy.s3.global.read.rate.limit.mb</td>  <td>0</td>  <td>Limit the maximum read speed for all connections. Set value less than or equal to 0 to disable rate limits.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.header.metadata.max.size"></a> alluxio.proxy.s3.header.metadata.max.size</td>  <td>2KB</td>  <td>The maximum size to allow for user-defined metadata in S3 PUTrequest headers. Set to 0 to disable size limits.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.multipart.upload.cleaner.enabled"></a> alluxio.proxy.s3.multipart.upload.cleaner.enabled</td>  <td>false</td>  <td>Enable automatic cleanup of long-running multipart uploads.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.multipart.upload.cleaner.pool.size"></a> alluxio.proxy.s3.multipart.upload.cleaner.pool.size</td>  <td>1</td>  <td>The abort multipart upload cleaner pool size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.multipart.upload.cleaner.retry.count"></a> alluxio.proxy.s3.multipart.upload.cleaner.retry.count</td>  <td>3</td>  <td>The retry count when aborting a multipart upload fails.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.multipart.upload.cleaner.retry.delay"></a> alluxio.proxy.s3.multipart.upload.cleaner.retry.delay</td>  <td>10sec</td>  <td>The retry delay time when aborting a multipart upload fails.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.multipart.upload.cleaner.timeout"></a> alluxio.proxy.s3.multipart.upload.cleaner.timeout</td>  <td>10min</td>  <td>The timeout for aborting proxy s3 multipart upload automatically.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.single.connection.read.rate.limit.mb"></a> alluxio.proxy.s3.single.connection.read.rate.limit.mb</td>  <td>0</td>  <td>Limit the maximum read speed for each connection. Set value less than or equal to 0 to disable rate limits.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.tagging.restrictions.enabled"></a> alluxio.proxy.s3.tagging.restrictions.enabled</td>  <td>true</td>  <td>Toggles whether or not the Alluxio S3 API will enforce AWS S3 tagging restrictions (10 tags, 128 character keys, 256 character values) See https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging-managing.html.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.v2.async.heavy.pool.core.thread.number"></a> alluxio.proxy.s3.v2.async.heavy.pool.core.thread.number</td>  <td>8</td>  <td>Core thread number for async heavy thread pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.v2.async.heavy.pool.maximum.thread.number"></a> alluxio.proxy.s3.v2.async.heavy.pool.maximum.thread.number</td>  <td>64</td>  <td>Maximum thread number for async heavy thread pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.v2.async.heavy.pool.queue.size"></a> alluxio.proxy.s3.v2.async.heavy.pool.queue.size</td>  <td>65536</td>  <td>Queue size for async heavy thread pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.v2.async.light.pool.core.thread.number"></a> alluxio.proxy.s3.v2.async.light.pool.core.thread.number</td>  <td>8</td>  <td>Core thread number for async light thread pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.v2.async.light.pool.maximum.thread.number"></a> alluxio.proxy.s3.v2.async.light.pool.maximum.thread.number</td>  <td>64</td>  <td>Maximum thread number for async light thread pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.v2.async.light.pool.queue.size"></a> alluxio.proxy.s3.v2.async.light.pool.queue.size</td>  <td>65536</td>  <td>Queue size for async light thread pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.v2.async.processing.enabled"></a> alluxio.proxy.s3.v2.async.processing.enabled</td>  <td>false</td>  <td>(Experimental) If enabled, handle S3 request in async mode when v2 version of Alluxio s3 proxy service is enabled.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.v2.version.enabled"></a> alluxio.proxy.s3.v2.version.enabled</td>  <td>true</td>  <td>(Experimental) V2, an optimized version of Alluxio s3 proxy service.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.s3.writetype"></a> alluxio.proxy.s3.writetype</td>  <td>CACHE_THROUGH</td>  <td>Write type when creating buckets and objects through S3 API. Valid options are `MUST_CACHE` (write will only go to Alluxio and must be stored in Alluxio), `CACHE_THROUGH` (try to cache, write to UnderFS synchronously), `ASYNC_THROUGH` (try to cache, write to UnderFS asynchronously), `THROUGH` (no cache, write to UnderFS synchronously).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.stream.cache.timeout"></a> alluxio.proxy.stream.cache.timeout</td>  <td>1hour</td>  <td>The timeout for the input and output streams cache eviction in the proxy.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.web.bind.host"></a> alluxio.proxy.web.bind.host</td>  <td>0.0.0.0</td>  <td>The hostname that the Alluxio proxy's web server runs on.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.web.hostname"></a> alluxio.proxy.web.hostname</td>  <td></td>  <td>The hostname Alluxio proxy's web UI binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.proxy.web.port"></a> alluxio.proxy.web.port</td>  <td>39999</td>  <td>The port Alluxio proxy's web UI runs on.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.s3.rest.authentication.enabled"></a> alluxio.s3.rest.authentication.enabled</td>  <td>false</td>  <td>Whether to enable check s3 rest request header.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.s3.rest.authenticator.classname"></a> alluxio.s3.rest.authenticator.classname</td>  <td>alluxio.proxy.s3.auth.PassAllAuthenticator</td>  <td>The class's name is instantiated as an S3 authenticator.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.secondary.master.metastore.dir"></a> alluxio.secondary.master.metastore.dir</td>  <td>${alluxio.work.dir}/secondary-metastore</td>  <td>The secondary master metastore work directory. Only some metastores need disk.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.site.conf.dir"></a> alluxio.site.conf.dir</td>  <td>${alluxio.conf.dir}/,${user.home}/.alluxio/,/etc/alluxio/</td>  <td>Comma-separated search path for alluxio-site.properties. Note: overwriting this property will only work when it is passed as a JVM system property (e.g., appending "-Dalluxio.site.conf.dir"=&lt;NEW_VALUE&gt;" to $ALLUXIO_JAVA_OPTS). Setting it in alluxio-site.properties will not work.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.site.conf.rocks.block.file"></a> alluxio.site.conf.rocks.block.file</td>  <td></td>  <td>Path of file containing RocksDB block store configuration. A template configuration cab be found at ${alluxio.conf.dir}/rocks-block.ini.template. See https://github.com/facebook/rocksdb/blob/main/examples/rocksdb_option_file_example.ini for more information on RocksDB configuration files. If unset then a default configuration will be used.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.site.conf.rocks.inode.file"></a> alluxio.site.conf.rocks.inode.file</td>  <td></td>  <td>Path of file containing RocksDB inode store configuration. A template configuration cab be found at ${alluxio.conf.dir}/rocks-inode.ini.template. See https://github.com/facebook/rocksdb/blob/main/examples/rocksdb_option_file_example.ini for more information on RocksDB configuration files. If unset then a default configuration will be used.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.standalone.fuse.jvm.monitor.enabled"></a> alluxio.standalone.fuse.jvm.monitor.enabled</td>  <td>false</td>  <td>Whether to enable start JVM monitor thread on the standalone fuse process. This will start a thread to detect JVM-wide pauses induced by GC or other reasons.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.standby.master.metrics.sink.enabled"></a> alluxio.standby.master.metrics.sink.enabled</td>  <td>false</td>  <td>Whether a standby master runs the metric sink</td></tr>
<tr>  <td><a class="anchor" name="alluxio.standby.master.web.enabled"></a> alluxio.standby.master.web.enabled</td>  <td>false</td>  <td>Whether a standby master runs a web server</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.catalog.path"></a> alluxio.table.catalog.path</td>  <td>/catalog</td>  <td>The Alluxio file path for the table catalog metadata.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.catalog.udb.sync.timeout"></a> alluxio.table.catalog.udb.sync.timeout</td>  <td>1h</td>  <td>The timeout period for a db sync to finish in the catalog. If a synctakes longer than this timeout, the sync will be terminated.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.enabled"></a> alluxio.table.enabled</td>  <td>true</td>  <td>(Experimental) Enables the table service.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.journal.partitions.chunk.size"></a> alluxio.table.journal.partitions.chunk.size</td>  <td>500</td>  <td>The maximum table partitions number in a single journal entry.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.load.default.replication"></a> alluxio.table.load.default.replication</td>  <td>1</td>  <td>The default replication number of files under the SDS table after load option.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.transform.manager.job.history.retention.time"></a> alluxio.table.transform.manager.job.history.retention.time</td>  <td>300sec</td>  <td>The length of time the Alluxio Table Master should keep information about finished transformation jobs before they are discarded.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.transform.manager.job.monitor.interval"></a> alluxio.table.transform.manager.job.monitor.interval</td>  <td>10s</td>  <td>Job monitor is a heartbeat thread in the transform manager, this is the time interval in milliseconds the job monitor heartbeat is run to check the status of the transformation jobs and update table and partition locations after transformation.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.udb.hive.clientpool.MAX"></a> alluxio.table.udb.hive.clientpool.MAX</td>  <td>256</td>  <td>The maximum capacity of the hive client pool per hive metastore</td></tr>
<tr>  <td><a class="anchor" name="alluxio.table.udb.hive.clientpool.min"></a> alluxio.table.udb.hive.clientpool.min</td>  <td>16</td>  <td>The minimum capacity of the hive client pool per hive metastore</td></tr>
<tr>  <td><a class="anchor" name="alluxio.test.deprecated.key"></a> alluxio.test.deprecated.key</td>  <td></td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.tmp.dirs"></a> alluxio.tmp.dirs</td>  <td>/tmp</td>  <td>The path(s) to store Alluxio temporary files, use commas as delimiters. If multiple paths are specified, one will be selected at random per temporary file. Currently, only files to be uploaded to object stores are stored in these paths.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.allow.set.owner.failure"></a> alluxio.underfs.allow.set.owner.failure</td>  <td>false</td>  <td>Whether to allow setting owner in UFS to fail. When set to true, it is possible file or directory owners diverge between Alluxio and UFS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.auth.id"></a> alluxio.underfs.cephfs.auth.id</td>  <td>admin</td>  <td>Ceph client id for authentication.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.auth.key"></a> alluxio.underfs.cephfs.auth.key</td>  <td></td>  <td>CephX authentication key, base64 encoded.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.auth.keyfile"></a> alluxio.underfs.cephfs.auth.keyfile</td>  <td></td>  <td>Path to CephX authentication key file.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.auth.keyring"></a> alluxio.underfs.cephfs.auth.keyring</td>  <td>/etc/ceph/ceph.client.admin.keyring</td>  <td>Path to CephX authentication keyring file.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.conf.file"></a> alluxio.underfs.cephfs.conf.file</td>  <td>/etc/ceph/ceph.conf</td>  <td>Path to Ceph configuration file.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.conf.options"></a> alluxio.underfs.cephfs.conf.options</td>  <td></td>  <td>Extra configuration options for CephFS client.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.localize.reads"></a> alluxio.underfs.cephfs.localize.reads</td>  <td>false</td>  <td>Utilize Ceph localized reads feature.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.mds.namespace"></a> alluxio.underfs.cephfs.mds.namespace</td>  <td></td>  <td>CephFS filesystem to mount.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.mon.host"></a> alluxio.underfs.cephfs.mon.host</td>  <td>0.0.0.0</td>  <td>List of hosts or addresses to search for a Ceph monitor.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.mount.gid"></a> alluxio.underfs.cephfs.mount.gid</td>  <td>0</td>  <td>The group ID of CephFS mount.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.mount.point"></a> alluxio.underfs.cephfs.mount.point</td>  <td>/</td>  <td>Directory to mount on the CephFS filesystem.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cephfs.mount.uid"></a> alluxio.underfs.cephfs.mount.uid</td>  <td>0</td>  <td>The user ID of CephFS mount.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cleanup.enabled"></a> alluxio.underfs.cleanup.enabled</td>  <td>false</td>  <td>Whether or not to clean up under file storage periodically.Some ufs operations may not be completed and cleaned up successfully in normal ways and leave some intermediate data that needs periodical cleanup.If enabled, all the mount points will be cleaned up when a leader master starts or cleanup interval is reached. This should be used sparingly.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.cleanup.interval"></a> alluxio.underfs.cleanup.interval</td>  <td>1day</td>  <td>The interval for periodically cleaning all the  mounted under file storages.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.eventual.consistency.retry.base.sleep"></a> alluxio.underfs.eventual.consistency.retry.base.sleep</td>  <td>50ms</td>  <td>To handle eventually consistent storage semantics for certain under storages, Alluxio will perform retries when under storage metadata doesn't match Alluxio's expectations. These retries use exponential backoff. This property determines the base time for the exponential backoff.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.eventual.consistency.retry.max.num"></a> alluxio.underfs.eventual.consistency.retry.max.num</td>  <td>0</td>  <td>To handle eventually consistent storage semantics for certain under storages, Alluxio will perform retries when under storage metadata doesn't match Alluxio's expectations. These retries use exponential backoff. This property determines the maximum number of retries. This property defaults to 0 as modern object store UFSs provide strong consistency.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.eventual.consistency.retry.max.sleep"></a> alluxio.underfs.eventual.consistency.retry.max.sleep</td>  <td>30sec</td>  <td>To handle eventually consistent storage semantics for certain under storages, Alluxio will perform retries when under storage metadata doesn't match Alluxio's expectations. These retries use exponential backoff. This property determines the maximum wait time in the backoff.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.default.mode"></a> alluxio.underfs.gcs.default.mode</td>  <td>0700</td>  <td>Mode (in octal notation) for GCS objects if mode cannot be discovered.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.directory.suffix"></a> alluxio.underfs.gcs.directory.suffix</td>  <td>/</td>  <td>Directories are represented in GCS as zero-byte objects named with the specified suffix.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.owner.id.to.username.mapping"></a> alluxio.underfs.gcs.owner.id.to.username.mapping</td>  <td></td>  <td>Optionally, specify a preset gcs owner id to Alluxio username static mapping in the format "id1=user1;id2=user2". The Google Cloud Storage IDs can be found at the console address https://console.cloud.google.com/storage/settings . Please use the "Owners" one. This property key is only valid when alluxio.underfs.gcs.version=1</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.retry.delay.multiplier"></a> alluxio.underfs.gcs.retry.delay.multiplier</td>  <td>2</td>  <td>Delay multiplier while retrying requests on the ufs</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.retry.initial.delay"></a> alluxio.underfs.gcs.retry.initial.delay</td>  <td>1000</td>  <td>Initial delay before attempting the retry on the ufs</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.retry.jitter"></a> alluxio.underfs.gcs.retry.jitter</td>  <td>true</td>  <td>Enable delay jitter while retrying requests on the ufs</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.retry.max"></a> alluxio.underfs.gcs.retry.max</td>  <td>60</td>  <td>Maximum Number of retries on the ufs</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.retry.max.delay"></a> alluxio.underfs.gcs.retry.max.delay</td>  <td>1min</td>  <td>Maximum delay before attempting the retry on the ufs</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.retry.total.duration"></a> alluxio.underfs.gcs.retry.total.duration</td>  <td>5min</td>  <td>Maximum retry duration on the ufs</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.gcs.version"></a> alluxio.underfs.gcs.version</td>  <td>2</td>  <td>Specify the version of GCS module to use. GCS version "1" builds on top of jets3t package which requires fs.gcs.accessKeyId and fs.gcs.secretAccessKey. GCS version "2" build on top of Google cloud API which requires fs.gcs.credential.path</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.hdfs.configuration"></a> alluxio.underfs.hdfs.configuration</td>  <td>${alluxio.conf.dir}/core-site.xml:${alluxio.conf.dir}/hdfs-site.xml</td>  <td>Location of the HDFS configuration file to overwrite the default HDFS client configuration. Note that, these files must be availableon every node.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.hdfs.impl"></a> alluxio.underfs.hdfs.impl</td>  <td>org.apache.hadoop.hdfs.DistributedFileSystem</td>  <td>The implementation class of the HDFS as the under storage system.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.hdfs.prefixes"></a> alluxio.underfs.hdfs.prefixes</td>  <td>hdfs://,glusterfs:///</td>  <td>Optionally, specify which prefixes should run through the HDFS implementation of UnderFileSystem. The delimiter is any whitespace and/or ','.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.hdfs.remote"></a> alluxio.underfs.hdfs.remote</td>  <td>true</td>  <td>Boolean indicating whether or not the under storage worker nodes are remote with respect to Alluxio worker nodes. If set to true, Alluxio will not attempt to discover locality information from the under storage because locality is impossible. This will improve performance. The default value is true.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.io.threads"></a> alluxio.underfs.io.threads</td>  <td>Use 3*{CPU core count} for UFS IO.</td>  <td>Number of threads used for UFS IO operation</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.kodo.connect.timeout"></a> alluxio.underfs.kodo.connect.timeout</td>  <td>50sec</td>  <td>The connect timeout of kodo.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.kodo.downloadhost"></a> alluxio.underfs.kodo.downloadhost</td>  <td></td>  <td>The download domain of Kodo bucket.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.kodo.endpoint"></a> alluxio.underfs.kodo.endpoint</td>  <td></td>  <td>The endpoint of Kodo bucket.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.kodo.requests.max"></a> alluxio.underfs.kodo.requests.max</td>  <td>64</td>  <td>The maximum number of kodo connections.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.listing.length"></a> alluxio.underfs.listing.length</td>  <td>1000</td>  <td>The maximum number of directory entries to list in a single query to under file system. If the total number of entries is greater than the specified length, multiple queries will be issued.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.local.skip.broken.symlinks"></a> alluxio.underfs.local.skip.broken.symlinks</td>  <td>false</td>  <td>When set to true, any time the local underfs lists a broken symlink, it will treat the entry as if it didn't exist at all.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.logging.threshold"></a> alluxio.underfs.logging.threshold</td>  <td>10s</td>  <td>Logging a UFS API call when it takes more time than the threshold.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.object.store.breadcrumbs.enabled"></a> alluxio.underfs.object.store.breadcrumbs.enabled</td>  <td>true</td>  <td>Set this to false to prevent Alluxio from creating zero byte objects during read or list operations on object store UFS. Leaving this on enables more efficient listing of prefixes.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.object.store.mount.shared.publicly"></a> alluxio.underfs.object.store.mount.shared.publicly</td>  <td>false</td>  <td>Whether or not to share object storage under storage system mounted point with all Alluxio users. Note that this configuration has no effect on HDFS nor local UFS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.object.store.multi.range.chunk.size"></a> alluxio.underfs.object.store.multi.range.chunk.size</td>  <td>${alluxio.user.block.size.bytes.default}</td>  <td>Default chunk size for ranged reads from multi-range object input streams.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.object.store.service.threads"></a> alluxio.underfs.object.store.service.threads</td>  <td>20</td>  <td>The number of threads in executor pool for parallel object store UFS operations, such as directory renames and deletes.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.object.store.skip.parent.directory.creation"></a> alluxio.underfs.object.store.skip.parent.directory.creation</td>  <td>true</td>  <td>Do not create parent directory for new files. Object stores generally uses prefix which is not required for creating new files. Skipping parent directory is recommended for better performance. Set this to false if the object store requires prefix creation for new files.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.object.store.streaming.upload.part.timeout"></a> alluxio.underfs.object.store.streaming.upload.part.timeout</td>  <td></td>  <td>Timeout for uploading part when using streaming uploads.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.obs.intermediate.upload.clean.age"></a> alluxio.underfs.obs.intermediate.upload.clean.age</td>  <td>3day</td>  <td>Streaming uploads may not have been completed/aborted correctly and need periodical ufs cleanup. If ufs cleanup is enabled, intermediate multipart uploads in all non-readonly OBS mount points older than this age will be cleaned. This may impact other ongoing upload operations, so a large clean age is encouraged.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.obs.streaming.upload.enabled"></a> alluxio.underfs.obs.streaming.upload.enabled</td>  <td>false</td>  <td>(Experimental) If true, using streaming upload to write to OBS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.obs.streaming.upload.partition.size"></a> alluxio.underfs.obs.streaming.upload.partition.size</td>  <td>64MB</td>  <td>Maximum allowable size of a single buffer file when using S3A streaming upload. When the buffer file reaches the partition size, it will be uploaded and the upcoming data will write to other buffer files.If the partition size is too small, OBS upload speed might be affected. </td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.obs.streaming.upload.threads"></a> alluxio.underfs.obs.streaming.upload.threads</td>  <td>20</td>  <td>the number of threads to use for streaming upload data to OBS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.connection.max"></a> alluxio.underfs.oss.connection.max</td>  <td>1024</td>  <td>The maximum number of OSS connections.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.connection.timeout"></a> alluxio.underfs.oss.connection.timeout</td>  <td>50sec</td>  <td>The timeout when connecting to OSS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.connection.ttl"></a> alluxio.underfs.oss.connection.ttl</td>  <td>-1</td>  <td>The TTL of OSS connections in ms.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.ecs.ram.role"></a> alluxio.underfs.oss.ecs.ram.role</td>  <td></td>  <td>The RAM role of current owner of ECS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.intermediate.upload.clean.age"></a> alluxio.underfs.oss.intermediate.upload.clean.age</td>  <td>3day</td>  <td>Streaming uploads may not have been completed/aborted correctly and need periodical ufs cleanup. If ufs cleanup is enabled, intermediate multipart uploads in all non-readonly OSS mount points older than this age will be cleaned. This may impact other ongoing upload operations, so a large clean age is encouraged.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.retry.max"></a> alluxio.underfs.oss.retry.max</td>  <td>3</td>  <td>The maximum number of OSS error retry.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.socket.timeout"></a> alluxio.underfs.oss.socket.timeout</td>  <td>50sec</td>  <td>The timeout of OSS socket.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.streaming.upload.enabled"></a> alluxio.underfs.oss.streaming.upload.enabled</td>  <td>false</td>  <td>(Experimental) If true, using streaming upload to write to OSS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.streaming.upload.partition.size"></a> alluxio.underfs.oss.streaming.upload.partition.size</td>  <td>64MB</td>  <td>Maximum allowable size of a single buffer file when using OSS streaming upload. When the buffer file reaches the partition size, it will be uploaded and the upcoming data will write to other buffer files.If the partition size is too small, OSS upload speed might be affected. </td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.streaming.upload.threads"></a> alluxio.underfs.oss.streaming.upload.threads</td>  <td>20</td>  <td>the number of threads to use for streaming upload data to OSS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.sts.ecs.metadata.service.endpoint"></a> alluxio.underfs.oss.sts.ecs.metadata.service.endpoint</td>  <td>http://100.100.100.200/latest/meta-data/ram/security-credentials/</td>  <td>The ECS metadata service endpoint for Aliyun STS</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.sts.enabled"></a> alluxio.underfs.oss.sts.enabled</td>  <td>false</td>  <td>Whether to enable oss STS(Security Token Service).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.oss.sts.token.refresh.interval.ms"></a> alluxio.underfs.oss.sts.token.refresh.interval.ms</td>  <td>30m</td>  <td>Time before an OSS Security Token is considered expired and will be automatically renewed</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.ozone.prefixes"></a> alluxio.underfs.ozone.prefixes</td>  <td>o3fs://,ofs://</td>  <td>Specify which prefixes should run through the Ozone implementation of UnderFileSystem. The delimiter is any whitespace and/or ','. The default value is "o3fs://,ofs://".</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.persistence.async.temp.dir"></a> alluxio.underfs.persistence.async.temp.dir</td>  <td>.alluxio_ufs_persistence</td>  <td>The temporary directory used for async persistence in the ufs</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.admin.threads.max"></a> alluxio.underfs.s3.admin.threads.max</td>  <td>20</td>  <td>The maximum number of threads to use for metadata operations when communicating with S3. These operations may be fairly concurrent and frequent but should not take much time to process.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.connection.ttl"></a> alluxio.underfs.s3.connection.ttl</td>  <td>-1</td>  <td>The expiration time of S3 connections in ms. -1 means the connection will never expire.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.default.mode"></a> alluxio.underfs.s3.default.mode</td>  <td>0700</td>  <td>Mode (in octal notation) for S3 objects if mode cannot be discovered.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.directory.suffix"></a> alluxio.underfs.s3.directory.suffix</td>  <td>/</td>  <td>Directories are represented in S3 as zero-byte objects named with the specified suffix.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.disable.dns.buckets"></a> alluxio.underfs.s3.disable.dns.buckets</td>  <td>false</td>  <td>Optionally, specify to make all S3 requests path style.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.endpoint"></a> alluxio.underfs.s3.endpoint</td>  <td></td>  <td>Optionally, to reduce data latency or visit resources which are separated in different AWS regions, specify a regional endpoint to make aws requests. An endpoint is a URL that is the entry point for a web service. For example, s3.cn-north-1.amazonaws.com.cn is an entry point for the Amazon S3 service in beijing region.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.endpoint.region"></a> alluxio.underfs.s3.endpoint.region</td>  <td></td>  <td>Optionally, set the S3 endpoint region. If not provided, inducted from the endpoint uri or set to null</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.inherit.acl"></a> alluxio.underfs.s3.inherit.acl</td>  <td>true</td>  <td>Set this property to false to disable inheriting bucket ACLs on objects. Note that the translation from bucket ACLs to Alluxio user permissions is best effort as some S3-like storage services doe not implement ACLs fully compatible with S3.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.intermediate.upload.clean.age"></a> alluxio.underfs.s3.intermediate.upload.clean.age</td>  <td>3day</td>  <td>Streaming uploads may not have been completed/aborted correctly and need periodical ufs cleanup. If ufs cleanup is enabled, intermediate multipart uploads in all non-readonly S3 mount points older than this age will be cleaned. This may impact other ongoing upload operations, so a large clean age is encouraged.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.list.objects.v1"></a> alluxio.underfs.s3.list.objects.v1</td>  <td>false</td>  <td>Whether to use version 1 of GET Bucket (List Objects) API.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.max.error.retry"></a> alluxio.underfs.s3.max.error.retry</td>  <td></td>  <td>The maximum number of retry attempts for failed retryable requests.Setting this property will override the AWS SDK default.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.owner.id.to.username.mapping"></a> alluxio.underfs.s3.owner.id.to.username.mapping</td>  <td></td>  <td>Optionally, specify a preset s3 canonical id to Alluxio username static mapping, in the format "id1=user1;id2=user2". The AWS S3 canonical ID can be found at the console address https://console.aws.amazon.com/iam/home?#security_credential . Please expand the "Account Identifiers" tab and refer to "Canonical User ID". Unspecified owner id will map to a default empty username</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.proxy.host"></a> alluxio.underfs.s3.proxy.host</td>  <td></td>  <td>Optionally, specify a proxy host for communicating with S3.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.proxy.port"></a> alluxio.underfs.s3.proxy.port</td>  <td></td>  <td>Optionally, specify a proxy port for communicating with S3.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.region"></a> alluxio.underfs.s3.region</td>  <td></td>  <td>Optionally, set the S3 bucket region. If not provided, will enable the global bucket access with extra requests</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.request.timeout"></a> alluxio.underfs.s3.request.timeout</td>  <td>1min</td>  <td>The timeout for a single request to S3. Infinity if set to 0. Setting this property to a non-zero value can improve performance by avoiding the long tail of requests to S3. For very slow connections to S3, consider increasing this value or setting it to 0.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.secure.http.enabled"></a> alluxio.underfs.s3.secure.http.enabled</td>  <td>false</td>  <td>Whether or not to use HTTPS protocol when communicating with S3.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.server.side.encryption.enabled"></a> alluxio.underfs.s3.server.side.encryption.enabled</td>  <td>false</td>  <td>Whether or not to encrypt data stored in S3.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.signer.algorithm"></a> alluxio.underfs.s3.signer.algorithm</td>  <td></td>  <td>The signature algorithm which should be used to sign requests to the s3 service. This is optional, and if not set, the client will automatically determine it. For interacting with an S3 endpoint which only supports v2 signatures, set this to "S3SignerType".</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.socket.timeout"></a> alluxio.underfs.s3.socket.timeout</td>  <td>50sec</td>  <td>Length of the socket timeout when communicating with S3.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.streaming.upload.enabled"></a> alluxio.underfs.s3.streaming.upload.enabled</td>  <td>false</td>  <td>(Experimental) If true, using streaming upload to write to S3.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.streaming.upload.partition.size"></a> alluxio.underfs.s3.streaming.upload.partition.size</td>  <td>64MB</td>  <td>Maximum allowable size of a single buffer file when using S3A streaming upload. When the buffer file reaches the partition size, it will be uploaded and the upcoming data will write to other buffer files.If the partition size is too small, S3A upload speed might be affected. </td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.threads.max"></a> alluxio.underfs.s3.threads.max</td>  <td>40</td>  <td>The maximum number of threads to use for communicating with S3 and the maximum number of concurrent connections to S3. Includes both threads for data upload and metadata operations. This number should be at least as large as the max admin threads plus max upload threads.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.s3.upload.threads.max"></a> alluxio.underfs.s3.upload.threads.max</td>  <td>20</td>  <td>For an Alluxio worker, this is the maximum number of threads to use for uploading data to S3 for multipart uploads. These operations can be fairly expensive, so multiple threads are encouraged. However, this also splits the bandwidth between threads, meaning the overall latency for completing an upload will be higher for more threads. For the Alluxio master, this is the maximum number of threads used for the rename (copy) operation. It is recommended that value should be greater than or equal to alluxio.underfs.object.store.service.threads</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.strict.version.match.enabled"></a> alluxio.underfs.strict.version.match.enabled</td>  <td>false</td>  <td>When enabled, Alluxio finds the UFS connector by strict version matching. Otherwise only version prefix is compared.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.web.connnection.timeout"></a> alluxio.underfs.web.connnection.timeout</td>  <td>60s</td>  <td>Default timeout for a http connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.web.header.last.modified"></a> alluxio.underfs.web.header.last.modified</td>  <td>EEE, dd MMM yyyy HH:mm:ss zzz</td>  <td>Date format of last modified for a http response header.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.web.parent.names"></a> alluxio.underfs.web.parent.names</td>  <td>Parent Directory,..,../</td>  <td>The text of the http link for the parent directory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.underfs.web.titles"></a> alluxio.underfs.web.titles</td>  <td>Index of,Directory listing for</td>  <td>The title of the content for a http url.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.cors.allow.credential"></a> alluxio.web.cors.allow.credential</td>  <td>false</td>  <td>Enable request include credential.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.cors.allow.headers"></a> alluxio.web.cors.allow.headers</td>  <td>*</td>  <td>Which headers is allowed for cors. use * allow all any header.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.cors.allow.methods"></a> alluxio.web.cors.allow.methods</td>  <td>*</td>  <td>Which methods is allowed for cors. use * allow all any method.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.cors.allow.origins"></a> alluxio.web.cors.allow.origins</td>  <td>*</td>  <td>Which origins is allowed for cors. use * allow all any origin.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.cors.enabled"></a> alluxio.web.cors.enabled</td>  <td>false</td>  <td>Set to true to enable Cross-Origin Resource Sharing for RESTful APIendpoints.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.cors.exposed.headers"></a> alluxio.web.cors.exposed.headers</td>  <td>*</td>  <td>Which headers are allowed to set in response when access cross-origin resource. use * allow all any header.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.cors.max.age"></a> alluxio.web.cors.max.age</td>  <td>-1</td>  <td>Maximum number of seconds the results can be cached. -1 means no cache.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.file.info.enabled"></a> alluxio.web.file.info.enabled</td>  <td>true</td>  <td>Whether detailed file information are enabled for the web UI.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.refresh.interval"></a> alluxio.web.refresh.interval</td>  <td>15s</td>  <td>The amount of time to await before refreshing the Web UI if it is set to auto refresh.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.threaddump.log.enabled"></a> alluxio.web.threaddump.log.enabled</td>  <td>false</td>  <td>Whether thread information is also printed to the log when the thread dump api is accessed</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.threads"></a> alluxio.web.threads</td>  <td>1</td>  <td>How many threads to serve Alluxio web UI.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.web.ui.enabled"></a> alluxio.web.ui.enabled</td>  <td>true</td>  <td>Whether the master/worker will have Web UI enabled. If set to false, the master/worker will not have Web UI page, but the RESTful endpoints and metrics will still be available.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.work.dir"></a> alluxio.work.dir</td>  <td>${alluxio.home}</td>  <td>The directory to use for Alluxio's working directory. By default, the journal, logs, and under file storage data (if using local filesystem) are written here.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.address"></a> alluxio.zookeeper.address</td>  <td></td>  <td>Address of ZooKeeper.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.auth.enabled"></a> alluxio.zookeeper.auth.enabled</td>  <td>true</td>  <td>If true, enable client-side Zookeeper authentication.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.connection.timeout"></a> alluxio.zookeeper.connection.timeout</td>  <td>15s</td>  <td>Connection timeout for Alluxio (job) masters to select the leading (job) master when connecting to Zookeeper</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.election.path"></a> alluxio.zookeeper.election.path</td>  <td>/alluxio/election</td>  <td>Election directory in ZooKeeper.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.enabled"></a> alluxio.zookeeper.enabled</td>  <td>false</td>  <td>If true, setup master fault tolerant mode using ZooKeeper.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.job.election.path"></a> alluxio.zookeeper.job.election.path</td>  <td>/alluxio/job_election</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.job.leader.path"></a> alluxio.zookeeper.job.leader.path</td>  <td>/alluxio/job_leader</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.leader.connection.error.policy"></a> alluxio.zookeeper.leader.connection.error.policy</td>  <td>SESSION</td>  <td>Connection error policy defines how errors on zookeeper connections to be treated in leader election. STANDARD policy treats every connection event as failure.SESSION policy relies on zookeeper sessions for judging failures, helping leader to retain its status, as long as its session is protected.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.leader.inquiry.retry"></a> alluxio.zookeeper.leader.inquiry.retry</td>  <td>10</td>  <td>The number of retries to inquire leader from ZooKeeper.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.leader.path"></a> alluxio.zookeeper.leader.path</td>  <td>/alluxio/leader</td>  <td>Leader directory in ZooKeeper.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.zookeeper.session.timeout"></a> alluxio.zookeeper.session.timeout</td>  <td>60s</td>  <td>Session timeout to use when connecting to Zookeeper</td></tr>
<tr>  <td><a class="anchor" name="fs.azure.account.oauth2.client.endpoint"></a> fs.azure.account.oauth2.client.endpoint</td>  <td></td>  <td>The oauth endpoint for ABFS.</td></tr>
<tr>  <td><a class="anchor" name="fs.azure.account.oauth2.client.id"></a> fs.azure.account.oauth2.client.id</td>  <td></td>  <td>The client id for ABFS.</td></tr>
<tr>  <td><a class="anchor" name="fs.azure.account.oauth2.client.secret"></a> fs.azure.account.oauth2.client.secret</td>  <td></td>  <td>The client secret for ABFS.</td></tr>
<tr>  <td><a class="anchor" name="fs.azure.account.oauth2.msi.endpoint"></a> fs.azure.account.oauth2.msi.endpoint</td>  <td></td>  <td>MSI endpoint</td></tr>
<tr>  <td><a class="anchor" name="fs.azure.account.oauth2.msi.tenant"></a> fs.azure.account.oauth2.msi.tenant</td>  <td></td>  <td>MSI Tenant ID</td></tr>
<tr>  <td><a class="anchor" name="fs.cos.access.key"></a> fs.cos.access.key</td>  <td></td>  <td>The access key of COS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.cos.app.id"></a> fs.cos.app.id</td>  <td></td>  <td>The app id of COS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.cos.connection.max"></a> fs.cos.connection.max</td>  <td>1024</td>  <td>The maximum number of COS connections.</td></tr>
<tr>  <td><a class="anchor" name="fs.cos.connection.timeout"></a> fs.cos.connection.timeout</td>  <td>50sec</td>  <td>The timeout of connecting to COS.</td></tr>
<tr>  <td><a class="anchor" name="fs.cos.region"></a> fs.cos.region</td>  <td></td>  <td>The region name of COS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.cos.secret.key"></a> fs.cos.secret.key</td>  <td></td>  <td>The secret key of COS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.cos.socket.timeout"></a> fs.cos.socket.timeout</td>  <td>50sec</td>  <td>The timeout of COS socket.</td></tr>
<tr>  <td><a class="anchor" name="fs.gcs.accessKeyId"></a> fs.gcs.accessKeyId</td>  <td></td>  <td>The access key of GCS bucket. This property key is only valid when alluxio.underfs.gcs.version=1</td></tr>
<tr>  <td><a class="anchor" name="fs.gcs.credential.path"></a> fs.gcs.credential.path</td>  <td></td>  <td>The json file path of Google application credentials. This property key is only valid when alluxio.underfs.gcs.version=2</td></tr>
<tr>  <td><a class="anchor" name="fs.gcs.secretAccessKey"></a> fs.gcs.secretAccessKey</td>  <td></td>  <td>The secret key of GCS bucket. This property key is only valid when alluxio.underfs.gcs.version=1</td></tr>
<tr>  <td><a class="anchor" name="fs.kodo.accesskey"></a> fs.kodo.accesskey</td>  <td></td>  <td>The access key of Kodo bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.kodo.secretkey"></a> fs.kodo.secretkey</td>  <td></td>  <td>The secret key of Kodo bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.obs.accessKey"></a> fs.obs.accessKey</td>  <td></td>  <td>The access key of OBS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.obs.bucketType"></a> fs.obs.bucketType</td>  <td>obs</td>  <td>The type of bucket (obs/pfs).</td></tr>
<tr>  <td><a class="anchor" name="fs.obs.endpoint"></a> fs.obs.endpoint</td>  <td>obs.myhwclouds.com</td>  <td>The endpoint of OBS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.obs.secretKey"></a> fs.obs.secretKey</td>  <td></td>  <td>The secret key of OBS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.oss.accessKeyId"></a> fs.oss.accessKeyId</td>  <td></td>  <td>The access key of OSS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.oss.accessKeySecret"></a> fs.oss.accessKeySecret</td>  <td></td>  <td>The secret key of OSS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.oss.endpoint"></a> fs.oss.endpoint</td>  <td></td>  <td>The endpoint key of OSS bucket.</td></tr>
<tr>  <td><a class="anchor" name="fs.swift.auth.method"></a> fs.swift.auth.method</td>  <td></td>  <td>Choice of authentication method: [tempauth (default), swiftauth, keystone, keystonev3].</td></tr>
<tr>  <td><a class="anchor" name="fs.swift.auth.url"></a> fs.swift.auth.url</td>  <td></td>  <td>Authentication URL for REST server, e.g., http://server:8090/auth/v1.0.</td></tr>
<tr>  <td><a class="anchor" name="fs.swift.password"></a> fs.swift.password</td>  <td></td>  <td>The password used for user:tenant authentication.</td></tr>
<tr>  <td><a class="anchor" name="fs.swift.region"></a> fs.swift.region</td>  <td></td>  <td>Service region when using Keystone authentication.</td></tr>
<tr>  <td><a class="anchor" name="fs.swift.simulation"></a> fs.swift.simulation</td>  <td></td>  <td>Whether to simulate a single node Swift backend for testing purposes: true or false (default).</td></tr>
<tr>  <td><a class="anchor" name="fs.swift.tenant"></a> fs.swift.tenant</td>  <td></td>  <td>Swift user for authentication.</td></tr>
<tr>  <td><a class="anchor" name="fs.swift.user"></a> fs.swift.user</td>  <td></td>  <td>Swift tenant for authentication.</td></tr>
<tr>  <td><a class="anchor" name="s3a.accessKeyId"></a> s3a.accessKeyId</td>  <td></td>  <td>The access key of S3 bucket.</td></tr>
<tr>  <td><a class="anchor" name="s3a.secretKey"></a> s3a.secretKey</td>  <td></td>  <td>The secret key of S3 bucket.</td></tr>

</tbody></table>

## Master Configuration

The master configuration specifies information regarding the master node, such as the address and
the port number.

<table class="table table-striped">
<tbody><tr><th>Property Name</th><th>Default</th><th>Description</th></tr>
<tr>  <td><a class="anchor" name="alluxio.master.audit.logging.enabled"></a> alluxio.master.audit.logging.enabled</td>  <td>false</td>  <td>Set to true to enable file system master audit.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.audit.logging.queue.capacity"></a> alluxio.master.audit.logging.queue.capacity</td>  <td>10000</td>  <td>Capacity of the queue used by audit logging.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.abandon.timeout"></a> alluxio.master.backup.abandon.timeout</td>  <td>1min</td>  <td>Duration after which leader will abandon the backup if it has not received heartbeat from backup-worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.connect.interval.max"></a> alluxio.master.backup.connect.interval.max</td>  <td>30sec</td>  <td>Maximum delay between each connection attempt to backup-leader.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.connect.interval.min"></a> alluxio.master.backup.connect.interval.min</td>  <td>1sec</td>  <td>Minimum delay between each connection attempt to backup-leader.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.delegation.enabled"></a> alluxio.master.backup.delegation.enabled</td>  <td>true</td>  <td>Whether to delegate journals to standby masters in HA cluster.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.directory"></a> alluxio.master.backup.directory</td>  <td>/alluxio_backups</td>  <td>Default directory for writing master metadata backups. This path is an absolute path of the root UFS. For example, if the root ufs directory is hdfs://host:port/alluxio/data, the default backup directory will be hdfs://host:port/alluxio_backups.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.entry.buffer.count"></a> alluxio.master.backup.entry.buffer.count</td>  <td>10000</td>  <td>How many journal entries to buffer during a back-up.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.heartbeat.interval"></a> alluxio.master.backup.heartbeat.interval</td>  <td>2sec</td>  <td>Interval at which stand-by master that is taking the backup will update the leading master with current backup status.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.state.lock.exclusive.duration"></a> alluxio.master.backup.state.lock.exclusive.duration</td>  <td>0ms</td>  <td>Alluxio master will allow only exclusive locking of the state-lock for this duration. This duration starts after masters are started for the first time. User RPCs will fail to acquire state-lock during this phase and a backup is guaranteed take the state-lock meanwhile.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.state.lock.forced.duration"></a> alluxio.master.backup.state.lock.forced.duration</td>  <td>15min</td>  <td>Exclusive locking of the state-lock will timeout after this duration is spent on forced phase.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.state.lock.interrupt.cycle.enabled"></a> alluxio.master.backup.state.lock.interrupt.cycle.enabled</td>  <td>false</td>  <td>This controls whether RPCs that are waiting/holding state-lock in shared-mode will be interrupted while state-lock is taken exclusively.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.state.lock.interrupt.cycle.interval"></a> alluxio.master.backup.state.lock.interrupt.cycle.interval</td>  <td>30sec</td>  <td>The interval at which the RPCs that are waiting/holding state-lock in shared-mode will be interrupted while state-lock is taken exclusively.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.suspend.timeout"></a> alluxio.master.backup.suspend.timeout</td>  <td>3min</td>  <td>Timeout for when suspend request is not followed by a backup request.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.backup.transport.timeout"></a> alluxio.master.backup.transport.timeout</td>  <td>30sec</td>  <td>Communication timeout for messaging between masters for coordinating backup.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.bind.host"></a> alluxio.master.bind.host</td>  <td>0.0.0.0</td>  <td>The hostname that Alluxio master binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.block.scan.invalid.batch.max.size"></a> alluxio.master.block.scan.invalid.batch.max.size</td>  <td>10000000</td>  <td>The invalid block max batch size when the master is scanning the invalid blocks, minus number means no limit.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.container.id.reservation.size"></a> alluxio.master.container.id.reservation.size</td>  <td>1000</td>  <td>The number of container ids to 'reserve' before having to journal container id state. This allows the master to return container ids within the reservation, without having to write to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.daily.backup.enabled"></a> alluxio.master.daily.backup.enabled</td>  <td>false</td>  <td>Whether or not to enable daily primary master metadata backup.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.daily.backup.files.retained"></a> alluxio.master.daily.backup.files.retained</td>  <td>3</td>  <td>The maximum number of backup files to keep in the backup directory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.daily.backup.state.lock.grace.mode"></a> alluxio.master.daily.backup.state.lock.grace.mode</td>  <td>TIMEOUT</td>  <td>Grace mode helps taking the state-lock exclusively for backup with minimum disruption to existing RPCs. This low-impact locking phase is called grace-cycle. Two modes are supported: TIMEOUT/FORCED.TIMEOUT: Means exclusive locking will timeout if it cannot acquire the lockwith grace-cycle. FORCED: Means the state-lock will be taken forcefully if grace-cycle fails to acquire it. Forced phase might trigger interrupting of existing RPCs if it is enabled.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.daily.backup.state.lock.sleep.duration"></a> alluxio.master.daily.backup.state.lock.sleep.duration</td>  <td>5m</td>  <td>The duration that controls how long the lock waiter sleeps within a single grace-cycle.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.daily.backup.state.lock.timeout"></a> alluxio.master.daily.backup.state.lock.timeout</td>  <td>1h</td>  <td>The max duration for a grace-cycle.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.daily.backup.state.lock.try.duration"></a> alluxio.master.daily.backup.state.lock.try.duration</td>  <td>2m</td>  <td>The duration that controls how long the state-lock is tried within a single grace-cycle.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.daily.backup.time"></a> alluxio.master.daily.backup.time</td>  <td>05:00</td>  <td>Default UTC time for writing daily master metadata backups. The accepted time format is hour:minute which is based on a 24-hour clock (E.g., 05:30, 06:00, and 22:04). Backing up metadata requires a pause in master metadata changes, so please set this value to an off-peak time to avoid interfering with other users of the system.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.addresses"></a> alluxio.master.embedded.journal.addresses</td>  <td></td>  <td>A comma-separated list of journal addresses for all masters in the cluster. The format is 'hostname1:port1,hostname2:port2,...'. When left unset, Alluxio uses ${alluxio.master.hostname}:${alluxio.master.embedded.journal.port} by default</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.catchup.retry.wait"></a> alluxio.master.embedded.journal.catchup.retry.wait</td>  <td>1s</td>  <td>Time for embedded journal leader to wait before retrying a catch up. This is added to avoid excessive retries when server is not ready.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.election.timeout.max"></a> alluxio.master.embedded.journal.election.timeout.max</td>  <td>20s</td>  <td>The max election timeout for the embedded journal. When a random period between ${alluxio.master.embedded.journal.election.timeout.min} and ${alluxio.master.embedded.journal.election.timeout.max} elapses without a master receiving any messages, the master will attempt to become the primary Election timeout will be waited initially when the cluster is forming. So larger values for election timeout will cause longer start-up time. Smaller values might introduce instability to leadership.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.election.timeout.min"></a> alluxio.master.embedded.journal.election.timeout.min</td>  <td>10s</td>  <td>The min election timeout for the embedded journal.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.entry.size.max"></a> alluxio.master.embedded.journal.entry.size.max</td>  <td>10MB</td>  <td>The maximum single journal entry size allowed to be flushed. This value should be smaller than 30MB. Set to a larger value to allow larger journal entries when using the Alluxio Catalog service.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.flush.size.max"></a> alluxio.master.embedded.journal.flush.size.max</td>  <td>160MB</td>  <td>The maximum size in bytes of journal entries allowed in concurrent journal flushing (journal IO to standby masters and IO to local disks).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.port"></a> alluxio.master.embedded.journal.port</td>  <td>19200</td>  <td>The port to use for embedded journal communication with other masters.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.raft.client.request.interval"></a> alluxio.master.embedded.journal.raft.client.request.interval</td>  <td>100ms</td>  <td>Base interval for retrying Raft client calls. The retry policy is ExponentialBackoffRetry</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.raft.client.request.timeout"></a> alluxio.master.embedded.journal.raft.client.request.timeout</td>  <td>60sec</td>  <td>Time after which calls made through the Raft client timeout.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.ratis.config"></a> alluxio.master.embedded.journal.ratis.config</td>  <td></td>  <td>Prefix for Apache Ratis internal configuration options. For example, setting alluxio.master.embedded.journal.ratis.config.raft.server.rpc.request.timeout will set ratis.config.raft.server.rpc.request.timeout on the Ratis service in the Alluxio master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.retry.cache.expiry.time"></a> alluxio.master.embedded.journal.retry.cache.expiry.time</td>  <td>60s</td>  <td>The time for embedded journal server retry cache to expire. Setting a bigger value allows embedded journal server to cache the responses for a longer time in case of journal writer retries, but will take up more memory in master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.snapshot.replication.chunk.size"></a> alluxio.master.embedded.journal.snapshot.replication.chunk.size</td>  <td>4MB</td>  <td>The stream chunk size used by masters to replicate snapshots.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.snapshot.replication.compression.level"></a> alluxio.master.embedded.journal.snapshot.replication.compression.level</td>  <td>1</td>  <td>The zip compression level of sending a snapshot from one master to another. Only applicable when alluxio.master.embedded.journal.snapshot.replication.compression.type is not NO_COMPRESSION. The zip format defines ten levels of compression, ranging from 0 (no compression, but very fast) to 9 (best compression, but slow). Or -1 for the system default compression level.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.snapshot.replication.compression.type"></a> alluxio.master.embedded.journal.snapshot.replication.compression.type</td>  <td>NO_COMPRESSION</td>  <td>The type of compression to use when transferring a snapshot from one master to another. Options are NO_COMPRESSION, GZIP, TAR_GZIP</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.transport.max.inbound.message.size"></a> alluxio.master.embedded.journal.transport.max.inbound.message.size</td>  <td>100MB</td>  <td>The maximum size of a message that can be sent to the embedded journal server node.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.transport.request.timeout.ms"></a> alluxio.master.embedded.journal.transport.request.timeout.ms</td>  <td>5sec</td>  <td>The duration after which embedded journal masters will timeout messages sent between each other. Lower values might cause leadership instability when the network is slow.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.unsafe.flush.enabled"></a> alluxio.master.embedded.journal.unsafe.flush.enabled</td>  <td>false</td>  <td>If true, embedded journal entries will be committed without waiting for the entry to be flushed to disk. This may improve performance of write operations on the Alluxio master if the journal is written to a slow or contested disk. WARNING: enabling this property may result in metadata loss if half or more of the master nodes fail. See Ratis property raft.server.log.unsafe-flush.enabled at https://github.com/apache/ratis/blob/master/ratis-docs/src/site/markdown/configuraions.md.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.embedded.journal.write.timeout"></a> alluxio.master.embedded.journal.write.timeout</td>  <td>30sec</td>  <td>Maximum time to wait for a write/flush on embedded journal.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.failover.collect.info"></a> alluxio.master.failover.collect.info</td>  <td>true</td>  <td>If true, the primary master will persist metrics and jstack into the log folder when it transitions to standby. </td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.file.access.time.journal.flush.interval"></a> alluxio.master.file.access.time.journal.flush.interval</td>  <td>1h</td>  <td>The minimum interval between files access time update journal entries get flushed asynchronously. Setting it to a non-positive value will make the the journal update synchronous. Asynchronous update reduces the performance impact of tracking access time but can lose some access time update when master stops unexpectedly.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.file.access.time.update.precision"></a> alluxio.master.file.access.time.update.precision</td>  <td>1d</td>  <td>The file last access time is precise up to this value. Setting it toa non-positive value will update last access time on every file access operation.Longer precision will help reduce the performance impact of tracking access time by reduce the amount of metadata writes occur while reading the same group of files repetitively.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.file.access.time.updater.enabled"></a> alluxio.master.file.access.time.updater.enabled</td>  <td>true</td>  <td>If enabled, file access time updater will update the file last access time when an inode is accessed. This property can be turned off to improve performance and reduce the number of journal entries if your application does not rely on the file access time metadata.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.file.access.time.updater.shutdown.timeout"></a> alluxio.master.file.access.time.updater.shutdown.timeout</td>  <td>1sec</td>  <td>Maximum time to wait for access updater to stop on shutdown.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.filesystem.liststatus.result.message.length"></a> alluxio.master.filesystem.liststatus.result.message.length</td>  <td>10000</td>  <td>Count of items on each list-status response message.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.filesystem.merge.inode.journals"></a> alluxio.master.filesystem.merge.inode.journals</td>  <td>true</td>  <td>If enabled, the file system master inode related journalswill be merged and submitted BEFORE the inode path lock is released. Due to the performance consideration, this will not apply to the metadata sync, where journals are still flushed asynchronously.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.filesystem.operation.retry.cache.enabled"></a> alluxio.master.filesystem.operation.retry.cache.enabled</td>  <td>true</td>  <td>If enabled, each filesystem operation will be tracked on all masters, in order to avoid re-execution of client retries.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.filesystem.operation.retry.cache.size"></a> alluxio.master.filesystem.operation.retry.cache.size</td>  <td>100000</td>  <td>Size of fs operation retry cache.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.format.file.prefix"></a> alluxio.master.format.file.prefix</td>  <td>_format_</td>  <td>The file prefix of the file generated in the journal directory when the journal is formatted. The master will search for a file with this prefix when determining if the journal is formatted.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.heartbeat.timeout"></a> alluxio.master.heartbeat.timeout</td>  <td>10min</td>  <td>Timeout between leader master and standby master indicating a lost master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.hostname"></a> alluxio.master.hostname</td>  <td></td>  <td>The hostname of Alluxio master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.backup.when.corrupted"></a> alluxio.master.journal.backup.when.corrupted</td>  <td>true</td>  <td>Takes a backup automatically when encountering journal corruption</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.catchup.protect.enabled"></a> alluxio.master.journal.catchup.protect.enabled</td>  <td>true</td>  <td>(Experimental) make sure the journal catchup finish before joining the quorum in fault tolerant mode when starting the master process and before the current master becoming the leader.This is added to prevent frequently leadership transition during heavy journal catchup stage. Catchup is only implemented in ufs journal with Zookeeper.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.checkpoint.period.entries"></a> alluxio.master.journal.checkpoint.period.entries</td>  <td>2000000</td>  <td>The number of journal entries to write before creating a new journal checkpoint.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.exit.on.demotion"></a> alluxio.master.journal.exit.on.demotion</td>  <td>false</td>  <td>(Experimental) When this flag is set to true, the master process may start as the primary or standby in a quorum, but at any point in time after becoming a primary it is demoted to standby, the process will shut down. This leaves the responsibility of restarting the master to re-join the quorum (e.g. in case of a journal failure on a particular node) to an external entity such as kubernetes or systemd.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.flush.batch.time"></a> alluxio.master.journal.flush.batch.time</td>  <td>100ms</td>  <td>Time to wait for batching journal writes.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.flush.timeout"></a> alluxio.master.journal.flush.timeout</td>  <td>5min</td>  <td>The amount of time to keep retrying journal writes before giving up and shutting down the master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.folder"></a> alluxio.master.journal.folder</td>  <td>${alluxio.work.dir}/journal</td>  <td>The path to store master journal logs. When using the UFS journal this could be a URI like hdfs://namenode:port/alluxio/journal. When using the embedded journal this must be a local path</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.gc.period"></a> alluxio.master.journal.gc.period</td>  <td>2min</td>  <td>Frequency with which to scan for and delete stale journal checkpoints.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.gc.threshold"></a> alluxio.master.journal.gc.threshold</td>  <td>5min</td>  <td>Minimum age for garbage collecting checkpoints.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.init.from.backup"></a> alluxio.master.journal.init.from.backup</td>  <td></td>  <td>A uri for a backup to initialize the journal from. When the master becomes primary, if it sees that its journal is freshly formatted, it will restore its state from the backup. When running multiple masters, this property must be configured on all masters since it isn't known during startup which master will become the first primary.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.local.log.compaction"></a> alluxio.master.journal.local.log.compaction</td>  <td>true</td>  <td>Whether to employ a quorum level log compaction policy or a local (individual) log compaction policy.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.log.size.bytes.max"></a> alluxio.master.journal.log.size.bytes.max</td>  <td>10MB</td>  <td>If a log file is bigger than this value, it will rotate to next file.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.request.data.timeout"></a> alluxio.master.journal.request.data.timeout</td>  <td>20000</td>  <td>Time to wait for follower to respond to request to send a new snapshot</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.request.info.timeout"></a> alluxio.master.journal.request.info.timeout</td>  <td>10000</td>  <td>Time to wait for follower to respond to request to get information about its latest snapshot</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.retry.interval"></a> alluxio.master.journal.retry.interval</td>  <td>1sec</td>  <td>The amount of time to sleep between retrying journal flushes</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.space.monitor.interval"></a> alluxio.master.journal.space.monitor.interval</td>  <td>10min</td>  <td>How often to check and update information on space utilization of the journal disk. This is currently only compatible with linux-basedsystems and when alluxio.master.journal.type is configured to EMBEDDED</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.space.monitor.percent.free.threshold"></a> alluxio.master.journal.space.monitor.percent.free.threshold</td>  <td>10</td>  <td>When the percent of free space on any disk which backs the journal falls below this percentage, begin logging warning messages to let administrators know the journal disk(s) may be running low on space.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.tailer.shutdown.quiet.wait.time"></a> alluxio.master.journal.tailer.shutdown.quiet.wait.time</td>  <td>5sec</td>  <td>Before the standby master shuts down its tailer thread, there should be no update to the leader master's journal in this specified time period.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.tailer.sleep.time"></a> alluxio.master.journal.tailer.sleep.time</td>  <td>1sec</td>  <td>Time for the standby master to sleep for when it cannot find anything new in leader master's journal.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.temporary.file.gc.threshold"></a> alluxio.master.journal.temporary.file.gc.threshold</td>  <td>30min</td>  <td>Minimum age for garbage collecting temporary checkpoint files.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.type"></a> alluxio.master.journal.type</td>  <td>EMBEDDED</td>  <td>The type of journal to use. Valid options are UFS (store journal in UFS), EMBEDDED (use a journal embedded in the masters), and NOOP (do not use a journal)</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.journal.ufs.option"></a> alluxio.master.journal.ufs.option</td>  <td></td>  <td>The configuration to use for the journal operations.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.jvm.monitor.enabled"></a> alluxio.master.jvm.monitor.enabled</td>  <td>true</td>  <td>Whether to enable start JVM monitor thread on the master. This will start a thread to detect JVM-wide pauses induced by GC or other reasons.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.keytab.file"></a> alluxio.master.keytab.file</td>  <td></td>  <td>Kerberos keytab file for Alluxio master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.lock.pool.concurrency.level"></a> alluxio.master.lock.pool.concurrency.level</td>  <td>100</td>  <td>Maximum concurrency level for the lock pool</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.lock.pool.high.watermark"></a> alluxio.master.lock.pool.high.watermark</td>  <td>1000000</td>  <td>High watermark of lock pool size. When the size grows over the high watermark, a background thread starts evicting unused locks from the pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.lock.pool.initsize"></a> alluxio.master.lock.pool.initsize</td>  <td>1000</td>  <td>Initial size of the lock pool for master inodes.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.lock.pool.low.watermark"></a> alluxio.master.lock.pool.low.watermark</td>  <td>500000</td>  <td>Low watermark of lock pool size. When the size grows over the high watermark, a background thread will try to evict unused locks until the size reaches the low watermark.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.log.config.report.heartbeat.interval"></a> alluxio.master.log.config.report.heartbeat.interval</td>  <td>1h</td>  <td>The interval for periodically logging the configuration check report.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.lost.worker.deletion.timeout"></a> alluxio.master.lost.worker.deletion.timeout</td>  <td>30min</td>  <td>If a worker has no heartbeat with the master for more than this timeout, the master will totally forget this worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.lost.worker.detection.interval"></a> alluxio.master.lost.worker.detection.interval</td>  <td>10sec</td>  <td>The interval between Alluxio master detections to find lost workers based on updates from Alluxio workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.lost.worker.file.detection.interval"></a> alluxio.master.lost.worker.file.detection.interval</td>  <td>5min</td>  <td>The interval between Alluxio master detections to find lost files based on updates from Alluxio workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.merge.journal.context.num.entries.logging.threshold"></a> alluxio.master.merge.journal.context.num.entries.logging.threshold</td>  <td>10000</td>  <td>The logging threshold of number of journal entries which are held in a merge journal context. This log may help debug memory exhaustion issues.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.concurrent.sync.dedup"></a> alluxio.master.metadata.concurrent.sync.dedup</td>  <td>false</td>  <td>If set to true, a metadata sync request will be skipped and doesn't trigger a UFS sync when there have already been other requests syncing the same path. The outstanding metadata sync request will wait until these syncs are done and return SyncStatus.NOT_NEED.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.concurrency.level"></a> alluxio.master.metadata.sync.concurrency.level</td>  <td>6</td>  <td>The maximum number of concurrent sync tasks running for a given sync operation</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.executor.pool.size"></a> alluxio.master.metadata.sync.executor.pool.size</td>  <td>The total number of threads which can concurrently execute metadata sync operations.</td>  <td>The number of threads used to execute all metadata syncoperations</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.ignore.ttl"></a> alluxio.master.metadata.sync.ignore.ttl</td>  <td>false</td>  <td>Whether files created from metadata sync will ignore the TTL from the command/path conf and have no TTL.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.instrument.executor"></a> alluxio.master.metadata.sync.instrument.executor</td>  <td>false</td>  <td>If true the metadata sync thread pool executors will be instrumented with additional metrics.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.lock.pool.concurrency.level"></a> alluxio.master.metadata.sync.lock.pool.concurrency.level</td>  <td>20</td>  <td>Maximum concurrency level for the metadata sync lock pool</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.lock.pool.high.watermark"></a> alluxio.master.metadata.sync.lock.pool.high.watermark</td>  <td>50000</td>  <td>High watermark of metadata sync lock pool size. When the size grows over the high watermark, a background thread starts evicting unused locks from the pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.lock.pool.initsize"></a> alluxio.master.metadata.sync.lock.pool.initsize</td>  <td>1000</td>  <td>Initial size of the lock pool for master metadata sync.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.lock.pool.low.watermark"></a> alluxio.master.metadata.sync.lock.pool.low.watermark</td>  <td>20000</td>  <td>Low watermark of metadata sync lock pool size. When the size grows over the high watermark, a background thread will try to evict unused locks until the size reaches the low watermark.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.traversal.order"></a> alluxio.master.metadata.sync.traversal.order</td>  <td>BFS</td>  <td>The pending Path in the Inode SyncStream traversal order, DFS consumes less memory while BFS is more fair for all concurrent sync tasks. For more description see the comments of MetadataSyncTraversalOrder.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.ufs.prefetch.pool.size"></a> alluxio.master.metadata.sync.ufs.prefetch.pool.size</td>  <td>The number of threads which can concurrently fetch metadata from UFSes during a metadata sync operations.</td>  <td>The number of threads used to fetch UFS objects for all metadata syncoperations</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.ufs.prefetch.status"></a> alluxio.master.metadata.sync.ufs.prefetch.status</td>  <td>true</td>  <td>Whether or not to prefetch ufs status of children during metadata sync. Prefetching will facilitate the metadata sync process but will consume more memory to hold prefetched results.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metadata.sync.ufs.prefetch.timeout"></a> alluxio.master.metadata.sync.ufs.prefetch.timeout</td>  <td>100ms</td>  <td>The timeout for a metadata fetch operation from the UFSes. Adjust this timeout according to the expected UFS worst-case response time.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore"></a> alluxio.master.metastore</td>  <td>ROCKS</td>  <td>The type of metastore to use, either HEAP or ROCKS. The heap metastore keeps all metadata on-heap, while the rocks metastore stores some metadata on heap and some metadata on disk. The rocks metastore has the advantage of being able to support a large namespace (1 billion plus files) without needing a massive heap size.The metadata storage includes inode and block metadata. Users can override the type of metastore using alluxio.master.metastore.inode and alluxio.master.metastore.block. For example if alluxio.master.metastore=ROCKS but alluxio.master.metastore.inode=HEAP, then inodes are stored with HEAP and blocks are stored with ROCKS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.block"></a> alluxio.master.metastore.block</td>  <td>ROCKS</td>  <td>The type of block metastore to use, either HEAP or ROCKS. By default this uses alluxio.master.metastore.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.dir"></a> alluxio.master.metastore.dir</td>  <td>${alluxio.work.dir}/metastore</td>  <td>The metastore work directory. Only some metastores need disk.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.dir.block"></a> alluxio.master.metastore.dir.block</td>  <td>${alluxio.master.metastore.dir}</td>  <td>If the metastore is ROCKS, this property controls where the RocksDB stores block metadata. This property defaults to alluxio.master.metastore.dir. And it can be used to change block metadata storage path to a different disk to improve RocksDB performance.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.dir.inode"></a> alluxio.master.metastore.dir.inode</td>  <td>${alluxio.master.metastore.dir}</td>  <td>If the metastore is ROCKS, this property controls where the RocksDB stores inode metadata. This property defaults to alluxio.master.metastore.dir. And it can be used to change inode metadata storage path to a different disk to improve RocksDB performance.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.inode"></a> alluxio.master.metastore.inode</td>  <td>ROCKS</td>  <td>The type of inode metastore to use, either HEAP or ROCKS. By default this uses alluxio.master.metastore.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.inode.cache.evict.batch.size"></a> alluxio.master.metastore.inode.cache.evict.batch.size</td>  <td>1000</td>  <td>The batch size for evicting entries from the inode cache.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.inode.cache.high.water.mark.ratio"></a> alluxio.master.metastore.inode.cache.high.water.mark.ratio</td>  <td>0.85</td>  <td>The high water mark for the inode cache, as a ratio from high water mark to total cache size. If this is 0.85 and the max size is 10 million, the high water mark value is 8.5 million. When the cache reaches the high water mark, the eviction process will evict down to the low water mark.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.inode.cache.low.water.mark.ratio"></a> alluxio.master.metastore.inode.cache.low.water.mark.ratio</td>  <td>0.8</td>  <td>The low water mark for the inode cache, as a ratio from low water mark to total cache size. If this is 0.8 and the max size is 10 million, the low water mark value is 8 million. When the cache reaches the high water mark, the eviction process will evict down to the low water mark.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.inode.cache.max.size"></a> alluxio.master.metastore.inode.cache.max.size</td>  <td>{Max memory of master JVM} / 2 / 2 KB per inode</td>  <td>The number of inodes to cache on-heap. The default value is chosen based on half the amount of maximum available memory of master JVM at runtime, and the estimation that each inode takes up approximately 2 KB of memory. This only applies to off-heap metastores, e.g. ROCKS. Set this to 0 to disable the on-heap inode cache</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.inode.enumerator.buffer.count"></a> alluxio.master.metastore.inode.enumerator.buffer.count</td>  <td>10000</td>  <td>The number of entries to buffer during read-ahead enumeration.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.inode.inherit.owner.and.group"></a> alluxio.master.metastore.inode.inherit.owner.and.group</td>  <td>true</td>  <td>Whether to inherit the owner/group from the parent when creating a new inode path if empty</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.inode.iteration.crawler.count"></a> alluxio.master.metastore.inode.iteration.crawler.count</td>  <td>Use {CPU core count} for enumeration.</td>  <td>The number of threads used during inode tree enumeration.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.iterator.readahead.size"></a> alluxio.master.metastore.iterator.readahead.size</td>  <td>64MB</td>  <td>The read-ahead size (in bytes) for metastore iterators.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.metrics.refresh.interval"></a> alluxio.master.metastore.metrics.refresh.interval</td>  <td>5s</td>  <td>Interval with which the master refreshes and reports metastore metrics</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.block.location.block.index"></a> alluxio.master.metastore.rocks.block.location.block.index</td>  <td></td>  <td>The block index type to be used in the RocksDB block location table. If unset, the RocksDB default will be used. See https://rocksdb.org/blog/2018/08/23/data-block-hash-index.html</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.block.location.bloom.filter"></a> alluxio.master.metastore.rocks.block.location.bloom.filter</td>  <td>false</td>  <td>Whether or not to use a bloom filter in the Block location table in RocksDB. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/RocksDB-Bloom-Filter</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.block.location.cache.size"></a> alluxio.master.metastore.rocks.block.location.cache.size</td>  <td></td>  <td>The capacity in bytes of the RocksDB block location table LRU cache. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/Block-Cache</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.block.location.index"></a> alluxio.master.metastore.rocks.block.location.index</td>  <td></td>  <td>The index type to be used in the RocksDB block location table. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/Index-Block-Format</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.block.meta.block.index"></a> alluxio.master.metastore.rocks.block.meta.block.index</td>  <td></td>  <td>The block index type to be used in the RocksDB block metadata table. If unset, the RocksDB default will be used.See https://rocksdb.org/blog/2018/08/23/data-block-hash-index.html</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.block.meta.bloom.filter"></a> alluxio.master.metastore.rocks.block.meta.bloom.filter</td>  <td>false</td>  <td>Whether or not to use a bloom filter in the Block meta table in RocksDB. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/RocksDB-Bloom-Filter</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.block.meta.cache.size"></a> alluxio.master.metastore.rocks.block.meta.cache.size</td>  <td></td>  <td>The capacity in bytes of the RocksDB block metadata table LRU  cache. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/Block-Cache</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.block.meta.index"></a> alluxio.master.metastore.rocks.block.meta.index</td>  <td></td>  <td>The index type to be used in the RocksDB block metadata table. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/Index-Block-Format</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.checkpoint.compression.type"></a> alluxio.master.metastore.rocks.checkpoint.compression.type</td>  <td>LZ4_COMPRESSION</td>  <td>The compression algorithm that RocksDB uses internally. One of {NO_COMPRESSION SNAPPY_COMPRESSION ZLIB_COMPRESSION BZLIB2_COMPRESSION LZ4_COMPRESSION LZ4HC_COMPRESSION XPRESS_COMPRESSION ZSTD_COMPRESSION DISABLE_COMPRESSION_OPTION}</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.edge.block.index"></a> alluxio.master.metastore.rocks.edge.block.index</td>  <td></td>  <td>The block index type to be used in the RocksDB inode edge table. If unset, the RocksDB default will be used. See https://rocksdb.org/blog/2018/08/23/data-block-hash-index.html</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.edge.bloom.filter"></a> alluxio.master.metastore.rocks.edge.bloom.filter</td>  <td>false</td>  <td>Whether or not to use a bloom filter in the Inode edge table in RocksDB. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/RocksDB-Bloom-Filter</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.edge.cache.size"></a> alluxio.master.metastore.rocks.edge.cache.size</td>  <td></td>  <td>The capacity in bytes of the RocksDB Inode edge table LRU cache. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/Block-Cache</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.edge.index"></a> alluxio.master.metastore.rocks.edge.index</td>  <td></td>  <td>The index type to be used in the RocksDB Inode edge table. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/Index-Block-Format</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.inode.block.index"></a> alluxio.master.metastore.rocks.inode.block.index</td>  <td></td>  <td>The block index type to be used in the RocksDB inode table. If unset, the RocksDB default will be used. See https://rocksdb.org/blog/2018/08/23/data-block-hash-index.html</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.inode.bloom.filter"></a> alluxio.master.metastore.rocks.inode.bloom.filter</td>  <td>false</td>  <td>Whether or not to use a bloom filter in the Inode table in RocksDB. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/RocksDB-Bloom-Filter</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.inode.cache.size"></a> alluxio.master.metastore.rocks.inode.cache.size</td>  <td></td>  <td>The capacity in bytes of the RocksDB Inode table LRU cache. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/Block-Cache</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.inode.index"></a> alluxio.master.metastore.rocks.inode.index</td>  <td></td>  <td>The index type to be used in the RocksDB Inode table. If unset, the RocksDB default will be used. See https://github.com/facebook/rocksdb/wiki/Index-Block-Format</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.parallel.backup"></a> alluxio.master.metastore.rocks.parallel.backup</td>  <td>false</td>  <td>Whether to checkpoint rocksdb in parallel using the number of threads set by alluxio.master.metastore.rocks.parallel.backup.threads.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metastore.rocks.parallel.backup.threads"></a> alluxio.master.metastore.rocks.parallel.backup.threads</td>  <td>The default number of threads used by backing up rocksdb in parallel.</td>  <td>The number of threads used by backing up rocksdb in parallel.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metrics.file.size.distribution.buckets"></a> alluxio.master.metrics.file.size.distribution.buckets</td>  <td>1KB,1MB,10MB,100MB,1GB,10GB</td>  <td>Master metrics file size buckets</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metrics.heap.enabled"></a> alluxio.master.metrics.heap.enabled</td>  <td>false</td>  <td>Enable master heap estimate metrics</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metrics.service.threads"></a> alluxio.master.metrics.service.threads</td>  <td>5</td>  <td>The number of threads in metrics master executor pool for parallel processing metrics submitted by workers or clients and update cluster metrics.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.metrics.time.series.interval"></a> alluxio.master.metrics.time.series.interval</td>  <td>5min</td>  <td>Interval for which the master records metrics information. This affects the granularity of the metrics graphed in the UI.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.mount.table.root.alluxio"></a> alluxio.master.mount.table.root.alluxio</td>  <td>/</td>  <td>Alluxio root mount point.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.mount.table.root.option"></a> alluxio.master.mount.table.root.option</td>  <td></td>  <td>Configuration for the UFS of Alluxio root mount point.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.mount.table.root.readonly"></a> alluxio.master.mount.table.root.readonly</td>  <td>false</td>  <td>Whether Alluxio root mount point is readonly.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.mount.table.root.shared"></a> alluxio.master.mount.table.root.shared</td>  <td>true</td>  <td>Whether Alluxio root mount point is shared.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.mount.table.root.ufs"></a> alluxio.master.mount.table.root.ufs</td>  <td>${alluxio.work.dir}/underFSStorage</td>  <td>The storage address of the UFS at the Alluxio root mount point.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.network.flowcontrol.window"></a> alluxio.master.network.flowcontrol.window</td>  <td>2MB</td>  <td>The HTTP2 flow control window used by Alluxio master gRPC connections. Larger value will allow more data to be buffered but will use more memory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.network.keepalive.time"></a> alluxio.master.network.keepalive.time</td>  <td>2h</td>  <td>The amount of time for Alluxio master gRPC server to wait for a response before pinging the client to see if it is still alive.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.network.keepalive.timeout"></a> alluxio.master.network.keepalive.timeout</td>  <td>30sec</td>  <td>The maximum time for Alluxio master gRPC server to wait for a keepalive response before closing the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.network.max.inbound.message.size"></a> alluxio.master.network.max.inbound.message.size</td>  <td>100MB</td>  <td>The maximum size of a message that can be sent to the Alluxio master</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.network.permit.keepalive.time"></a> alluxio.master.network.permit.keepalive.time</td>  <td>30sec</td>  <td>Specify the most aggressive keep-alive time clients are permitted to configure. The server will try to detect clients exceeding this rate and when detected will forcefully close the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.periodic.block.integrity.check.interval"></a> alluxio.master.periodic.block.integrity.check.interval</td>  <td>1hr</td>  <td>The period for the block integrity check, disabled if &lt;= 0.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.periodic.block.integrity.check.repair"></a> alluxio.master.periodic.block.integrity.check.repair</td>  <td>true</td>  <td>Whether the system should delete orphaned blocks found during the periodic integrity check.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.persistence.blacklist"></a> alluxio.master.persistence.blacklist</td>  <td></td>  <td>Patterns to blacklist persist, comma separated, string match, no regex. This affects any async persist call (including ASYNC_THROUGH writes and CLI persist) but does not affect CACHE_THROUGH writes. Users may want to specify temporary files in the blacklist to avoid unnecessary I/O and errors. Some examples are `.staging` and `.tmp`.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.persistence.checker.interval"></a> alluxio.master.persistence.checker.interval</td>  <td>1s</td>  <td>How often the master checks persistence status for files written using ASYNC_THROUGH</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.persistence.initial.interval"></a> alluxio.master.persistence.initial.interval</td>  <td>1s</td>  <td>How often the  master persistence checker checks persistence status for files written using ASYNC_THROUGH</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.persistence.max.interval"></a> alluxio.master.persistence.max.interval</td>  <td>1hr</td>  <td>Max wait interval for master persistence checker persistence status for files written using ASYNC_THROUGH</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.persistence.max.total.wait.time"></a> alluxio.master.persistence.max.total.wait.time</td>  <td>1day</td>  <td>Total wait time for master persistence checker persistence status for files written using ASYNC_THROUGH</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.persistence.scheduler.interval"></a> alluxio.master.persistence.scheduler.interval</td>  <td>1s</td>  <td>How often the master schedules persistence jobs for files written using ASYNC_THROUGH</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.principal"></a> alluxio.master.principal</td>  <td></td>  <td>Kerberos principal for Alluxio master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.recursive.operation.journal.force.flush.max.entries"></a> alluxio.master.recursive.operation.journal.force.flush.max.entries</td>  <td>100</td>  <td>The threshold of the number of completed single operations in a recursive file system operation, e.g. delete file/set file attributes to trigger a force journal flush. Increasing the threshold decreases the possibility to see partial state of a recursive operation on a standby master but increases the memory consumption as alluxio holds more journal entries in memory. This config is only available when alluxio.master.filesystem.merge.inode.journalsis enabled.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.replication.check.interval"></a> alluxio.master.replication.check.interval</td>  <td>1min</td>  <td>How often the master runs background process to check replication level for files</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.addresses"></a> alluxio.master.rpc.addresses</td>  <td></td>  <td>A list of comma-separated host:port RPC addresses where the client should look for masters when using multiple masters without Zookeeper. This property is not used when Zookeeper is enabled, since Zookeeper already stores the master addresses.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.core.pool.size"></a> alluxio.master.rpc.executor.core.pool.size</td>  <td>500</td>  <td>The number of threads to keep in thread pool of master RPC ExecutorService.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.fjp.async"></a> alluxio.master.rpc.executor.fjp.async</td>  <td>true</td>  <td>This property is effective when alluxio.master.rpc.executor.type is set to ForkJoinPool. if true, it establishes local first-in-first-out scheduling mode for forked tasks that are never joined. This mode may be more appropriate than default locally stack-based mode in applications in which worker threads only process event-style asynchronous tasks.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.fjp.min.runnable"></a> alluxio.master.rpc.executor.fjp.min.runnable</td>  <td>1</td>  <td>This property is effective when alluxio.master.rpc.executor.type is set to ForkJoinPool. It controls the minimum allowed number of core threads not blocked. A value of 1 ensures liveness. A larger value might improve throughput but might also increase overhead.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.fjp.parallelism"></a> alluxio.master.rpc.executor.fjp.parallelism</td>  <td>2 * {CPU core count}</td>  <td>This property is effective when alluxio.master.rpc.executor.type is set to ForkJoinPool. It controls the parallelism level (internal queue count) of master RPC ExecutorService.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.keepalive"></a> alluxio.master.rpc.executor.keepalive</td>  <td>60sec</td>  <td>The keep alive time of a thread in master RPC ExecutorServicelast used before this thread is terminated (and replaced if necessary).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.max.pool.size"></a> alluxio.master.rpc.executor.max.pool.size</td>  <td>500</td>  <td>The maximum number of threads allowed for master RPC ExecutorService. When the maximum is reached, attempts to replace blocked threads fail.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.tpe.allow.core.threads.timeout"></a> alluxio.master.rpc.executor.tpe.allow.core.threads.timeout</td>  <td>true</td>  <td>This property is effective when alluxio.master.rpc.executor.type is set to ThreadPoolExecutor. It controls whether core threads can timeout and terminate when there is no work.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.tpe.queue.type"></a> alluxio.master.rpc.executor.tpe.queue.type</td>  <td>LINKED_BLOCKING_QUEUE</td>  <td>This property is effective when alluxio.master.rpc.executor.type is set to TPE. It specifies the internal task queue that's used by RPC ExecutorService. Supported values are: LINKED_BLOCKING_QUEUE, LINKED_BLOCKING_QUEUE_WITH_CAP, ARRAY_BLOCKING_QUEUE and SYNCHRONOUS_BLOCKING_QUEUE</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.executor.type"></a> alluxio.master.rpc.executor.type</td>  <td>TPE</td>  <td>Type of ExecutorService for Alluxio master gRPC server. Supported values are TPE (for ThreadPoolExecutor) and FJP (for ForkJoinPool).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.rpc.port"></a> alluxio.master.rpc.port</td>  <td>19998</td>  <td>The port for Alluxio master's RPC service.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.shell.backup.state.lock.grace.mode"></a> alluxio.master.shell.backup.state.lock.grace.mode</td>  <td>FORCED</td>  <td>Grace mode helps taking the state-lock exclusively for backup with minimum disruption to existing RPCs. This low-impact locking phase is called grace-cycle. Two modes are supported: TIMEOUT/FORCED.TIMEOUT: Means exclusive locking will timeout if it cannot acquire the lockwith grace-cycle. FORCED: Means the state-lock will be taken forcefully if grace-cycle fails to acquire it. Forced phase might trigger interrupting of existing RPCs if it is enabled.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.shell.backup.state.lock.sleep.duration"></a> alluxio.master.shell.backup.state.lock.sleep.duration</td>  <td>0s</td>  <td>The duration that controls how long the lock waiter sleeps within a single grace-cycle.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.shell.backup.state.lock.timeout"></a> alluxio.master.shell.backup.state.lock.timeout</td>  <td>0s</td>  <td>The max duration for a grace-cycle.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.shell.backup.state.lock.try.duration"></a> alluxio.master.shell.backup.state.lock.try.duration</td>  <td>0s</td>  <td>The duration that controls how long the state-lock is tried within a single grace-cycle.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.standby.heartbeat.interval"></a> alluxio.master.standby.heartbeat.interval</td>  <td>2min</td>  <td>The heartbeat interval between Alluxio primary master and standby masters.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.startup.block.integrity.check.enabled"></a> alluxio.master.startup.block.integrity.check.enabled</td>  <td>false</td>  <td>Whether the system should be checked on startup for orphaned blocks (blocks having no corresponding files but still taking system resource due to various system failures). Orphaned blocks will be deleted during master startup if this property is true. This property is available since 1.7.1</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.state.lock.error.threshold"></a> alluxio.master.state.lock.error.threshold</td>  <td>20</td>  <td>Used to trace and debug state lock issues. When a thread recursively acquires the state lock more than threshold, log an error for further debugging.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.active.cpu.load.ratio"></a> alluxio.master.throttle.active.cpu.load.ratio</td>  <td>0.5</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.active.heap.gc.time"></a> alluxio.master.throttle.active.heap.gc.time</td>  <td>1sec</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.active.heap.used.ratio"></a> alluxio.master.throttle.active.heap.used.ratio</td>  <td>0.5</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.active.rpc.queue.size"></a> alluxio.master.throttle.active.rpc.queue.size</td>  <td>50000</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.background.enabled"></a> alluxio.master.throttle.background.enabled</td>  <td>false</td>  <td>Whether to throttle the background job</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.enabled"></a> alluxio.master.throttle.enabled</td>  <td>true</td>  <td>The throttle service can monitor and throttle the master in case of overloaded</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.filesystem.op.per.sec"></a> alluxio.master.throttle.filesystem.op.per.sec</td>  <td>2000</td>  <td>The max filesystem operations can be made per second if throttling is triggered</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.filesystem.rpc.queue.size.limit"></a> alluxio.master.throttle.filesystem.rpc.queue.size.limit</td>  <td>1000</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.foreground.enabled"></a> alluxio.master.throttle.foreground.enabled</td>  <td>false</td>  <td>Whether to throttle the foreground job</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.heartbeat.interval"></a> alluxio.master.throttle.heartbeat.interval</td>  <td>3sec</td>  <td>The heartbeat interval for throttling monitor check</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.observed.pit.number"></a> alluxio.master.throttle.observed.pit.number</td>  <td>3</td>  <td>The number of indicator PITs used to evaluate the system status.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.overloaded.cpu.load.ratio"></a> alluxio.master.throttle.overloaded.cpu.load.ratio</td>  <td>0.95</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.overloaded.heap.gc.time"></a> alluxio.master.throttle.overloaded.heap.gc.time</td>  <td>10sec</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.overloaded.heap.used.ratio"></a> alluxio.master.throttle.overloaded.heap.used.ratio</td>  <td>0.9</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.overloaded.rpc.queue.size"></a> alluxio.master.throttle.overloaded.rpc.queue.size</td>  <td>150000</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.stressed.cpu.load.ratio"></a> alluxio.master.throttle.stressed.cpu.load.ratio</td>  <td>0.8</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.stressed.heap.gc.time"></a> alluxio.master.throttle.stressed.heap.gc.time</td>  <td>5sec</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.stressed.heap.used.ratio"></a> alluxio.master.throttle.stressed.heap.used.ratio</td>  <td>0.8</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.throttle.stressed.rpc.queue.size"></a> alluxio.master.throttle.stressed.rpc.queue.size</td>  <td>100000</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.tieredstore.global.level0.alias"></a> alluxio.master.tieredstore.global.level0.alias</td>  <td>MEM</td>  <td>The name of the highest storage tier in the entire system.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.tieredstore.global.level1.alias"></a> alluxio.master.tieredstore.global.level1.alias</td>  <td>SSD</td>  <td>The name of the second highest storage tier in the entire system.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.tieredstore.global.level2.alias"></a> alluxio.master.tieredstore.global.level2.alias</td>  <td>HDD</td>  <td>The name of the third highest storage tier in the entire system.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.tieredstore.global.levels"></a> alluxio.master.tieredstore.global.levels</td>  <td>3</td>  <td>The total number of storage tiers in the system.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.tieredstore.global.mediumtype"></a> alluxio.master.tieredstore.global.mediumtype</td>  <td>MEM,SSD,HDD</td>  <td>The list of medium types we support in the system.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ttl.checker.interval"></a> alluxio.master.ttl.checker.interval</td>  <td>1hour</td>  <td>How often to periodically check and delete/free the files with expired ttl value.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.active.sync.event.rate.interval"></a> alluxio.master.ufs.active.sync.event.rate.interval</td>  <td>60sec</td>  <td>The time interval we use to estimate incoming event rate</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.active.sync.interval"></a> alluxio.master.ufs.active.sync.interval</td>  <td>30sec</td>  <td>Time interval to periodically actively sync UFS</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.active.sync.max.activities"></a> alluxio.master.ufs.active.sync.max.activities</td>  <td>10</td>  <td>Max number of changes in a directory to be considered for active syncing</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.active.sync.max.age"></a> alluxio.master.ufs.active.sync.max.age</td>  <td>10</td>  <td>The maximum number of intervals we will wait to find a quiet period before we have to sync the directories</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.active.sync.poll.batch.size"></a> alluxio.master.ufs.active.sync.poll.batch.size</td>  <td>1024</td>  <td>The number of event batches that should be submitted together to a single thread for processing.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.active.sync.poll.timeout"></a> alluxio.master.ufs.active.sync.poll.timeout</td>  <td>10sec</td>  <td>Max time to wait before timing out a polling operation</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.active.sync.retry.timeout"></a> alluxio.master.ufs.active.sync.retry.timeout</td>  <td>10sec</td>  <td>The max total duration to retry failed active sync operations.A large duration is useful to handle transient failures such as an unresponsive under storage but can lock the inode tree being synced longer.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.active.sync.thread.pool.size"></a> alluxio.master.ufs.active.sync.thread.pool.size</td>  <td>The number of threads used by the active sync provider process active sync events. A higher number allow the master to use more CPU to process events from an event stream in parallel. If this value is too low, Alluxio may fall behind processing events. Defaults to # of processors / 2.</td>  <td>Max number of threads used to perform active sync</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.block.location.cache.capacity"></a> alluxio.master.ufs.block.location.cache.capacity</td>  <td>1000000</td>  <td>The capacity of the UFS block locations cache. This cache caches UFS block locations for files that are persisted but not in Alluxio space, so that listing status of these files do not need to repeatedly ask UFS for their block locations. If this is set to 0, the cache will be disabled.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.journal.max.catchup.time"></a> alluxio.master.ufs.journal.max.catchup.time</td>  <td>10min</td>  <td>The maximum time to wait for ufs journal catching up before listening to Zookeeper state change. This is added to prevent frequently leadership transition during heavy journal replay stage.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.path.cache.capacity"></a> alluxio.master.ufs.path.cache.capacity</td>  <td>100000</td>  <td>The capacity of the UFS sync path cache. This cache is used to approximate the `ONCE` metadata load behavior (see `alluxio.user.file.metadata.load.type`). Larger caches will consume more memory, but will better approximate the `ONCE` behavior.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.ufs.path.cache.threads"></a> alluxio.master.ufs.path.cache.threads</td>  <td>64</td>  <td>The maximum size of the thread pool for asynchronously processing paths for the UFS path cache. Greater number of threads will decrease the amount of staleness in the async cache, but may impact performance. If this is set to 0, the cache will be disabled, and `alluxio.user.file.metadata.load.type=ONCE` will behave like `ALWAYS`.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.unsafe.direct.persist.object.enabled"></a> alluxio.master.unsafe.direct.persist.object.enabled</td>  <td>true</td>  <td>When set to false, writing files using ASYNC_THROUGH or persist CLI with object stores as the UFS will first create temporary objects suffixed by ".alluxio.TIMESTAMP.tmp" in the object store before committed to the final UFS path. When set to true, files will be put to the destination path directly in the object store without staging with a temp suffix. Enabling this optimization by directly persisting files can significantly improve the efficiency writing to object store by making less data copy as rename in object store can be slow, but leaving a short vulnerability window for undefined behavior if a file is written using ASYNC_THROUGH but renamed or removed before the async persist operation completes, while this same file path was reused for other new files in Alluxio.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.update.check.enabled"></a> alluxio.master.update.check.enabled</td>  <td>true</td>  <td>Whether to check for update availability.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.update.check.interval"></a> alluxio.master.update.check.interval</td>  <td>7day</td>  <td>The interval to check for update availability.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.web.bind.host"></a> alluxio.master.web.bind.host</td>  <td>0.0.0.0</td>  <td>The hostname Alluxio master web UI binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.web.hostname"></a> alluxio.master.web.hostname</td>  <td></td>  <td>The hostname of Alluxio Master web UI.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.web.in.alluxio.data.page.count"></a> alluxio.master.web.in.alluxio.data.page.count</td>  <td>1000</td>  <td>The number of URIs showing in the In-Alluxio Data Web UI page.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.web.port"></a> alluxio.master.web.port</td>  <td>19999</td>  <td>The port Alluxio web UI runs on.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.whitelist"></a> alluxio.master.whitelist</td>  <td>/</td>  <td>A comma-separated list of prefixes of the paths which are cacheable, separated by semi-colons. Alluxio will try to cache the cacheable file when it is read for the first time.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.worker.connect.wait.time"></a> alluxio.master.worker.connect.wait.time</td>  <td>5sec</td>  <td>Alluxio master will wait a period of time after start up for all workers to register, before it starts accepting client requests. This property determines the wait time.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.worker.info.cache.refresh.time"></a> alluxio.master.worker.info.cache.refresh.time</td>  <td>10sec</td>  <td>The worker information list will be refreshed after being cached for this time period. If the refresh time is too big, operations on the job servers or clients may fail because of the stale worker info. If it is too small, continuously updating worker information may case lock contention in the block master</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.worker.register.lease.count"></a> alluxio.master.worker.register.lease.count</td>  <td>25</td>  <td>The number of workers that can register at the same time. Others will wait and retry until they are granted a RegisterLease. If you observe pressure on the master when many workers start up and register, tune down this parameter.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.worker.register.lease.enabled"></a> alluxio.master.worker.register.lease.enabled</td>  <td>true</td>  <td>Whether workers request for leases before they register. The RegisterLease is used by the master to control the concurrency of workers that are actively registering.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.worker.register.lease.respect.jvm.space"></a> alluxio.master.worker.register.lease.respect.jvm.space</td>  <td>true</td>  <td>Whether the master checks the availability on the JVM before granting a lease to a worker. If the master determines the JVM does not have enough space to accept a new worker, the RegisterLease will not be granted.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.worker.register.lease.ttl"></a> alluxio.master.worker.register.lease.ttl</td>  <td>1min</td>  <td>The TTL for a RegisterLease granted to the worker. Leases that exceed the TTL will be recycled and granted to other workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.worker.register.stream.response.timeout"></a> alluxio.master.worker.register.stream.response.timeout</td>  <td>10min</td>  <td>When the worker registers the master with streaming, the worker will be sending messages to the master during the streaming.During an active stream if the master have not heard from the worker for more than this timeout, the worker will be considered hanging and the stream will be closed.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.master.worker.timeout"></a> alluxio.master.worker.timeout</td>  <td>5min</td>  <td>Timeout between master and worker indicating a lost worker.</td></tr>

</tbody></table>

## Worker Configuration

The worker configuration specifies information regarding the worker nodes, such as the address and
the port number.

<table class="table table-striped">
<tbody><tr><th>Property Name</th><th>Default</th><th>Description</th></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.allocator.class"></a> alluxio.worker.allocator.class</td>  <td>alluxio.worker.block.allocator.MaxFreeAllocator</td>  <td>The strategy that a worker uses to allocate space among storage directories in certain storage layer. Valid options include: `alluxio.worker.block.allocator.MaxFreeAllocator`, `alluxio.worker.block.allocator.GreedyAllocator`, `alluxio.worker.block.allocator.RoundRobinAllocator`.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.bind.host"></a> alluxio.worker.bind.host</td>  <td>0.0.0.0</td>  <td>The hostname Alluxio's worker node binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.block.annotator.class"></a> alluxio.worker.block.annotator.class</td>  <td>alluxio.worker.block.annotator.LRUAnnotator</td>  <td>The strategy that a worker uses to annotate blocks in order to have an ordered view of them during internalmanagement tasks such as eviction and promotion/demotion.  Valid options include: `alluxio.worker.block.annotator.LRFUAnnotator`, `alluxio.worker.block.annotator.LRUAnnotator`, </td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.block.annotator.lrfu.attenuation.factor"></a> alluxio.worker.block.annotator.lrfu.attenuation.factor</td>  <td>2.0</td>  <td>A attenuation factor in [2, INF) to control the behavior of LRFU annotator.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.block.annotator.lrfu.step.factor"></a> alluxio.worker.block.annotator.lrfu.step.factor</td>  <td>0.25</td>  <td>A factor in [0, 1] to control the behavior of LRFU: smaller value makes LRFU more similar to LFU; and larger value makes LRFU closer to LRU.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.block.heartbeat.interval"></a> alluxio.worker.block.heartbeat.interval</td>  <td>1sec</td>  <td>The interval between block workers' heartbeats to update block status, storage health and other workers' information to Alluxio Master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.block.heartbeat.report.size.threshold"></a> alluxio.worker.block.heartbeat.report.size.threshold</td>  <td>1000000</td>  <td>When alluxio.worker.register.to.all.masters=true, because a worker will send block reports to all masters, we use a threshold to limit the unsent block report size in worker's memory. If the worker block heartbeat is larger than the threshold, we discard the heartbeat message and force the worker to register with that master with a full report.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.block.heartbeat.timeout"></a> alluxio.worker.block.heartbeat.timeout</td>  <td>${alluxio.worker.master.connect.retry.timeout}</td>  <td>The timeout value of block workers' heartbeats. If the worker can't connect to master before this interval expires, the worker will exit.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.block.master.client.pool.size"></a> alluxio.worker.block.master.client.pool.size</td>  <td>11</td>  <td>The block master client pool size on the Alluxio workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.block.store.type"></a> alluxio.worker.block.store.type</td>  <td>FILE</td>  <td>The implementation of LocalBlockStore that can be instantiated.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.container.hostname"></a> alluxio.worker.container.hostname</td>  <td></td>  <td>The container hostname if worker is running in a container.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.data.folder"></a> alluxio.worker.data.folder</td>  <td>/alluxioworker/</td>  <td>A relative path within each storage directory used as the data folder for Alluxio worker to put data for tiered store.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.data.folder.permissions"></a> alluxio.worker.data.folder.permissions</td>  <td>rwxrwxrwx</td>  <td>The permission set for the worker data folder. If short circuit is used this folder should be accessible by all users (rwxrwxrwx).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.data.folder.tmp"></a> alluxio.worker.data.folder.tmp</td>  <td>.tmp_blocks</td>  <td>A relative path in alluxio.worker.data.folder used to store the temporary data for uncommitted files.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.data.server.domain.socket.address"></a> alluxio.worker.data.server.domain.socket.address</td>  <td></td>  <td>The path to the domain socket. Short-circuit reads make use of a UNIX domain socket when this is set (non-empty). This is a special path in the file system that allows the client and the AlluxioWorker to communicate. You will need to set a path to this socket. The AlluxioWorker needs to be able to create the path. If alluxio.worker.data.server.domain.socket.as.uuid is set, the path should be the home directory for the domain socket. The full path for the domain socket with be {path}/{uuid}.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.data.server.domain.socket.as.uuid"></a> alluxio.worker.data.server.domain.socket.as.uuid</td>  <td>false</td>  <td>If true, the property alluxio.worker.data.server.domain.socket.addressis the path to the home directory for the domain socket and a unique identifier is used as the domain socket name. If false, the property is the absolute path to the UNIX domain socket.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.data.tmp.subdir.max"></a> alluxio.worker.data.tmp.subdir.max</td>  <td>1024</td>  <td>The maximum number of sub-directories allowed to be created in ${alluxio.worker.data.tmp.folder}.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.evictor.class"></a> alluxio.worker.evictor.class</td>  <td></td>  <td>The strategy that a worker uses to evict block files when a storage layer runs out of space. Valid options include `alluxio.worker.block.evictor.LRFUEvictor`, `alluxio.worker.block.evictor.GreedyEvictor`, `alluxio.worker.block.evictor.LRUEvictor`, `alluxio.worker.block.evictor.PartialLRUEvictor`.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.free.space.timeout"></a> alluxio.worker.free.space.timeout</td>  <td>10sec</td>  <td>The duration for which a worker will wait for eviction to make space available for a client write request.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.fuse.enabled"></a> alluxio.worker.fuse.enabled</td>  <td>false</td>  <td>If true, launch worker embedded Fuse application.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.hostname"></a> alluxio.worker.hostname</td>  <td></td>  <td>The hostname of Alluxio worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.jvm.monitor.enabled"></a> alluxio.worker.jvm.monitor.enabled</td>  <td>true</td>  <td>Whether to enable start JVM monitor thread on the worker. This will start a thread to detect JVM-wide pauses induced by GC or other reasons.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.keytab.file"></a> alluxio.worker.keytab.file</td>  <td></td>  <td>Kerberos keytab file for Alluxio worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.backoff.strategy"></a> alluxio.worker.management.backoff.strategy</td>  <td>ANY</td>  <td>Defines the backoff scope respected by background tasks. Supported values are ANY / DIRECTORY. ANY: Management tasks will backoff from worker when there is any user I/O.This mode will ensure low management task overhead in order to favor immediate user I/O performance. However, making progress on management tasks will require quite periods on the worker.DIRECTORY: Management tasks will backoff from directories with ongoing user I/O.This mode will give better chance of making progress on management tasks.However, immediate user I/O throughput might be reduced due to increased management task activity.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.block.transfer.concurrency.limit"></a> alluxio.worker.management.block.transfer.concurrency.limit</td>  <td>Use {CPU core count}/2 threads block transfer.</td>  <td>Puts a limit to how many block transfers are executed concurrently during management.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.load.detection.cool.down.time"></a> alluxio.worker.management.load.detection.cool.down.time</td>  <td>10sec</td>  <td>Management tasks will not run for this long after load detected. Any user I/O will still register as a load for this period of time after it is finished. Short durations might cause interference between user I/O and background tier management tasks. Long durations might cause starvation for background tasks.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.task.thread.count"></a> alluxio.worker.management.task.thread.count</td>  <td>Use {CPU core count} threads for all management tasks.</td>  <td>The number of threads for management task executor</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.tier.align.enabled"></a> alluxio.worker.management.tier.align.enabled</td>  <td>true</td>  <td>Whether to align tiers based on access pattern.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.tier.align.range"></a> alluxio.worker.management.tier.align.range</td>  <td>100</td>  <td>Maximum number of blocks to consider from one tier for a single alignment task.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.tier.align.reserved.bytes"></a> alluxio.worker.management.tier.align.reserved.bytes</td>  <td>1GB</td>  <td>The amount of space that is reserved from each storage directory for internal management tasks.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.tier.promote.enabled"></a> alluxio.worker.management.tier.promote.enabled</td>  <td>true</td>  <td>Whether to promote blocks to higher tiers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.tier.promote.quota.percent"></a> alluxio.worker.management.tier.promote.quota.percent</td>  <td>90</td>  <td>Max percentage of each tier that could be used for promotions. Promotions will be stopped to a tier once its used space go over this value. (0 means never promote, and, 100 means always promote.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.tier.promote.range"></a> alluxio.worker.management.tier.promote.range</td>  <td>100</td>  <td>Maximum number of blocks to consider from one tier for a single promote task.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.management.tier.swap.restore.enabled"></a> alluxio.worker.management.tier.swap.restore.enabled</td>  <td>true</td>  <td>Whether to run management swap-restore task when tier alignment cannot make progress.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.master.connect.retry.timeout"></a> alluxio.worker.master.connect.retry.timeout</td>  <td>1hour</td>  <td>Retry period before workers give up on connecting to master and exit.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.master.periodical.rpc.timeout"></a> alluxio.worker.master.periodical.rpc.timeout</td>  <td>5min</td>  <td>Timeout for periodical RPC between workers and the leading master. This property is added to prevent workers from hanging in periodical RPCs with previous leading master during flaky network situations. If the timeout is too short, periodical RPCs may not have enough time to get response from the leading master during heavy cluster load and high network latency.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.async.cache.manager.queue.max"></a> alluxio.worker.network.async.cache.manager.queue.max</td>  <td>512</td>  <td>The maximum number of outstanding async caching requests to cache blocks in each data server</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.async.cache.manager.threads.max"></a> alluxio.worker.network.async.cache.manager.threads.max</td>  <td>2 * {CPU core count}</td>  <td>The maximum number of threads used to cache blocks asynchronously in the data server.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.block.reader.threads.max"></a> alluxio.worker.network.block.reader.threads.max</td>  <td>2048</td>  <td>The maximum number of threads used to read blocks in the data server.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.block.writer.threads.max"></a> alluxio.worker.network.block.writer.threads.max</td>  <td>1024</td>  <td>The maximum number of threads used to write blocks in the data server.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.flowcontrol.window"></a> alluxio.worker.network.flowcontrol.window</td>  <td>2MB</td>  <td>The HTTP2 flow control window used by worker gRPC connections. Larger value will allow more data to be buffered but will use more memory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.keepalive.time"></a> alluxio.worker.network.keepalive.time</td>  <td>30sec</td>  <td>The amount of time for data server (for block reads and block writes) to wait for a response before pinging the client to see if it is still alive.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.keepalive.timeout"></a> alluxio.worker.network.keepalive.timeout</td>  <td>30sec</td>  <td>The maximum time for a data server (for block reads and block writes) to wait for a keepalive response before closing the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.max.inbound.message.size"></a> alluxio.worker.network.max.inbound.message.size</td>  <td>4MB</td>  <td>The max inbound message size used by worker gRPC connections.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.netty.boss.threads"></a> alluxio.worker.network.netty.boss.threads</td>  <td>1</td>  <td>How many threads to use for accepting new requests.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.netty.channel"></a> alluxio.worker.network.netty.channel</td>  <td>EPOLL</td>  <td>Netty channel type: NIO or EPOLL. If EPOLL is not available, this will automatically fall back to NIO.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.netty.shutdown.quiet.period"></a> alluxio.worker.network.netty.shutdown.quiet.period</td>  <td>2sec</td>  <td>The quiet period. When the netty server is shutting down, it will ensure that no RPCs occur during the quiet period. If an RPC occurs, then the quiet period will restart before shutting down the netty server.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.netty.watermark.high"></a> alluxio.worker.network.netty.watermark.high</td>  <td>32KB</td>  <td>Determines how many bytes can be in the write queue before switching to non-writable.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.netty.watermark.low"></a> alluxio.worker.network.netty.watermark.low</td>  <td>8KB</td>  <td>Once the high watermark limit is reached, the queue must be flushed down to the low watermark before switching back to writable.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.netty.worker.threads"></a> alluxio.worker.network.netty.worker.threads</td>  <td>2 * {CPU core count}</td>  <td>Number of threads to use for processing requests in worker</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.permit.keepalive.time"></a> alluxio.worker.network.permit.keepalive.time</td>  <td>30s</td>  <td>Specify the most aggressive keep-alive time clients are permitted to configure. The server will try to detect clients exceeding this rate and when detected will forcefully close the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.reader.buffer.pooled"></a> alluxio.worker.network.reader.buffer.pooled</td>  <td>true</td>  <td>Whether it is using pooled direct buffer or unpooled wrapped buffer when creating a buffer for remote read</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.reader.buffer.size"></a> alluxio.worker.network.reader.buffer.size</td>  <td>4MB</td>  <td>When a client reads from a remote worker, the maximum amount of data not received by client allowed before the worker pauses sending more data. If this value is lower than read chunk size, read performance may be impacted as worker waits more often for buffer to free up. Higher value will increase the memory consumed by each read request.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.reader.max.chunk.size.bytes"></a> alluxio.worker.network.reader.max.chunk.size.bytes</td>  <td>2MB</td>  <td>When a client read from a remote worker, the maximum chunk size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.shutdown.timeout"></a> alluxio.worker.network.shutdown.timeout</td>  <td>15sec</td>  <td>Maximum amount of time to wait until the worker gRPC server is shutdown (regardless of the quiet period).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.writer.buffer.size.messages"></a> alluxio.worker.network.writer.buffer.size.messages</td>  <td>8</td>  <td>When a client writes to a remote worker, the maximum number of data messages to buffer by the server for each request.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.network.zerocopy.enabled"></a> alluxio.worker.network.zerocopy.enabled</td>  <td>true</td>  <td>Whether zero copy is enabled on worker when processing data streams.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.async.restore.enabled"></a> alluxio.worker.page.store.async.restore.enabled</td>  <td>true</td>  <td>If this is enabled, cache restore state asynchronously.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.async.write.enabled"></a> alluxio.worker.page.store.async.write.enabled</td>  <td>false</td>  <td>If this is enabled, cache data asynchronously.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.async.write.threads"></a> alluxio.worker.page.store.async.write.threads</td>  <td>16</td>  <td>Number of threads to asynchronously cache data.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.dirs"></a> alluxio.worker.page.store.dirs</td>  <td>/tmp/alluxio_cache</td>  <td>A list of the directories where pages in paged block store are stored.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.eviction.retries"></a> alluxio.worker.page.store.eviction.retries</td>  <td>10</td>  <td>Max number of eviction retries.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.evictor.class"></a> alluxio.worker.page.store.evictor.class</td>  <td>alluxio.client.file.cache.evictor.LRUCacheEvictor</td>  <td>The strategy that worker uses to evict local cached pages when running out of space. Currently valid options include `alluxio.client.file.cache.evictor.LRUCacheEvictor`,`alluxio.client.file.cache.evictor.LFUCacheEvictor`.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.evictor.lfu.logbase"></a> alluxio.worker.page.store.evictor.lfu.logbase</td>  <td>2.0</td>  <td>The log base for client cache LFU evictor bucket index.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.evictor.nondeterministic.enabled"></a> alluxio.worker.page.store.evictor.nondeterministic.enabled</td>  <td>false</td>  <td>If this is enabled, the evictor picks uniformly from the worst k elements.Currently only LRU is supported.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.local.store.file.buckets"></a> alluxio.worker.page.store.local.store.file.buckets</td>  <td>1000</td>  <td>The number of file buckets for the page blocked store on local file system. It is recommended to set this to a high value if the number of unique files is expected to be high (# files / file buckets &lt;= 100,000).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.overhead"></a> alluxio.worker.page.store.overhead</td>  <td>0.1</td>  <td>A fraction value representing the storage overhead writing to disk. For example, with 1GB allocated cache space, and 10% storage overhead we expect no more than 1024MB / (1 + 10%) user data to store.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.page.size"></a> alluxio.worker.page.store.page.size</td>  <td>1MB</td>  <td>Size of each page in worker paged block store.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.quota.enabled"></a> alluxio.worker.page.store.quota.enabled</td>  <td>false</td>  <td>Whether to support cache quota.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.sizes"></a> alluxio.worker.page.store.sizes</td>  <td>512MB</td>  <td>A list of maximum cache size for each cache directory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.timeout.duration"></a> alluxio.worker.page.store.timeout.duration</td>  <td>-1</td>  <td>The timeout duration for local cache I/O operations (reading/writing/deleting). When this property is a positive value,local cache operations after timing out will fail and fallback to external file system but transparent to applications; when this property is a negative value, this feature is disabled.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.timeout.threads"></a> alluxio.worker.page.store.timeout.threads</td>  <td>32</td>  <td>The number of threads to handle cache I/O operation timeout, when alluxio.worker.page.store.timeout.duration is positive.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.page.store.type"></a> alluxio.worker.page.store.type</td>  <td>LOCAL</td>  <td>The type of page store to use for worker page store. Can be either `LOCAL` or `ROCKS`. The `LOCAL` page store stores all pages in a directory, the `ROCKS` page store utilizes rocksDB to persist the data.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.principal"></a> alluxio.worker.principal</td>  <td></td>  <td>Kerberos principal for Alluxio worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.ramdisk.size"></a> alluxio.worker.ramdisk.size</td>  <td>2/3 of total system memory, or 1GB if system memory size cannot be determined</td>  <td>The allocated memory for each worker node's ramdisk(s). It is recommended to set this value explicitly.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.lease.enabled"></a> alluxio.worker.register.lease.enabled</td>  <td>${alluxio.master.worker.register.lease.enabled}</td>  <td>Whether the worker requests a lease from the master before registering.This should be consistent with alluxio.master.worker.register.lease.enabled</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.lease.retry.max.duration"></a> alluxio.worker.register.lease.retry.max.duration</td>  <td>${alluxio.worker.master.connect.retry.timeout}</td>  <td>The total time on retrying to get a register lease, before giving up.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.lease.retry.sleep.max"></a> alluxio.worker.register.lease.retry.sleep.max</td>  <td>10sec</td>  <td>The maximum time to sleep before retrying to get a register lease.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.lease.retry.sleep.min"></a> alluxio.worker.register.lease.retry.sleep.min</td>  <td>1sec</td>  <td>The minimum time to sleep before retrying to get a register lease.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.stream.batch.size"></a> alluxio.worker.register.stream.batch.size</td>  <td>1000000</td>  <td>When the worker registers with the master using a stream, this defines the metadata of how many blocks should be send to the master in each batch.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.stream.complete.timeout"></a> alluxio.worker.register.stream.complete.timeout</td>  <td>5min</td>  <td>When the worker registers the master with streaming, after all messages have been sent to the master, the worker will wait for the registration to complete on the master side. If the master is unable to finish the registration and return success to the worker within this timeout, the worker will consider the registration failed.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.stream.deadline"></a> alluxio.worker.register.stream.deadline</td>  <td>15min</td>  <td>When the worker registers with the master using a stream, this defines the total deadline for the full stream to finish.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.stream.enabled"></a> alluxio.worker.register.stream.enabled</td>  <td>true</td>  <td>When the worker registers with the master, whether the request should be broken into a stream of smaller batches. This is useful when the worker's storage is large and we expect a large number of blocks. </td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.stream.response.timeout"></a> alluxio.worker.register.stream.response.timeout</td>  <td>${alluxio.master.worker.register.stream.response.timeout}</td>  <td>When the worker registers the master with streaming, the worker will be sending messages to the master during the streaming.During an active stream if the master have not responded to the worker for more than this timeout, the worker will consider the master is hanging and close the stream.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.register.to.all.masters"></a> alluxio.worker.register.to.all.masters</td>  <td>false</td>  <td>If enabled, workers will register themselves to all masters, instead of primary master only. This can be used to save the master failover time because the new primary immediately knows all existing workers and blocks. Can only be enabled when alluxio.standby.master.grpc.enabled is turned on.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.remote.io.slow.threshold"></a> alluxio.worker.remote.io.slow.threshold</td>  <td>10s</td>  <td>The time threshold for when a worker remote IO (read or write) of a single buffer is considered slow. When slow IO occurs, it is logged by a sampling logger.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.reviewer.class"></a> alluxio.worker.reviewer.class</td>  <td>alluxio.worker.block.reviewer.ProbabilisticBufferReviewer</td>  <td>(Experimental) The API is subject to change in the future.The strategy that a worker uses to review space allocation in the Allocator. Each time a block allocation decision is made by the Allocator, the Reviewer will review the decision and rejects it,if the allocation does not meet certain criteria of the Reviewer.The Reviewer prevents the worker to make a bad block allocation decision.Valid options include:`alluxio.worker.block.reviewer.ProbabilisticBufferReviewer`.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.reviewer.probabilistic.hardlimit.bytes"></a> alluxio.worker.reviewer.probabilistic.hardlimit.bytes</td>  <td>64MB</td>  <td>This is used by the `alluxio.worker.block.reviewer.ProbabilisticBufferReviewer`. When the free space in a storage dir falls below this hard limit, the ProbabilisticBufferReviewer will stop accepting new blocks into it.This is because we may load more data into existing blocks in the directory and their sizes may expand.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.reviewer.probabilistic.softlimit.bytes"></a> alluxio.worker.reviewer.probabilistic.softlimit.bytes</td>  <td>256MB</td>  <td>This is used by the `alluxio.worker.block.reviewer.ProbabilisticBufferReviewer`. We attempt to leave a buffer in each storage directory. When the free space in a certain storage directory on the worker falls below this soft limit, the chance that the Reviewer accepts new blocks into this directory goes down. This chance keeps falling linearly until it reaches 0, when the available space reaches the hard limit.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.core.pool.size"></a> alluxio.worker.rpc.executor.core.pool.size</td>  <td>100</td>  <td>The number of threads to keep in thread pool of worker RPC ExecutorService.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.fjp.async"></a> alluxio.worker.rpc.executor.fjp.async</td>  <td>true</td>  <td>This property is effective when alluxio.worker.rpc.executor.type is set to ForkJoinPool. if true, it establishes local first-in-first-out scheduling mode for forked tasks that are never joined. This mode may be more appropriate than default locally stack-based mode in applications in which worker threads only process event-style asynchronous tasks.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.fjp.min.runnable"></a> alluxio.worker.rpc.executor.fjp.min.runnable</td>  <td>1</td>  <td>This property is effective when alluxio.worker.rpc.executor.type is set to ForkJoinPool. It controls the minimum allowed number of core threads not blocked. A value of 1 ensures liveness. A larger value might improve throughput but might also increase overhead.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.fjp.parallelism"></a> alluxio.worker.rpc.executor.fjp.parallelism</td>  <td>2 * {CPU core count}</td>  <td>This property is effective when alluxio.worker.rpc.executor.type is set to ForkJoinPool. It controls the parallelism level (internal queue count) of master RPC ExecutorService.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.keepalive"></a> alluxio.worker.rpc.executor.keepalive</td>  <td>60sec</td>  <td>The keep alive time of a thread in worker RPC ExecutorServicelast used before this thread is terminated (and replaced if necessary).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.max.pool.size"></a> alluxio.worker.rpc.executor.max.pool.size</td>  <td>1000</td>  <td>The maximum number of threads allowed for worker RPC ExecutorService. When the maximum is reached, attempts to replace blocked threads fail.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.tpe.allow.core.threads.timeout"></a> alluxio.worker.rpc.executor.tpe.allow.core.threads.timeout</td>  <td>true</td>  <td>This property is effective when alluxio.worker.rpc.executor.type is set to ThreadPoolExecutor. It controls whether core threads can timeout and terminate when there is no work.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.tpe.queue.type"></a> alluxio.worker.rpc.executor.tpe.queue.type</td>  <td>LINKED_BLOCKING_QUEUE_WITH_CAP</td>  <td>This property is effective when alluxio.worker.rpc.executor.type is set to TPE. It specifies the internal task queue that's used by RPC ExecutorService. Supported values are: LINKED_BLOCKING_QUEUE, LINKED_BLOCKING_QUEUE_WITH_CAP, ARRAY_BLOCKING_QUEUE and SYNCHRONOUS_BLOCKING_QUEUE</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.executor.type"></a> alluxio.worker.rpc.executor.type</td>  <td>TPE</td>  <td>Type of ExecutorService for Alluxio worker gRPC server. Supported values are TPE (for ThreadPoolExecutor) and FJP (for ForkJoinPool).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.rpc.port"></a> alluxio.worker.rpc.port</td>  <td>29999</td>  <td>The port for Alluxio worker's RPC service.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.session.timeout"></a> alluxio.worker.session.timeout</td>  <td>1min</td>  <td>Timeout between worker and client connection indicating a lost session connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.startup.timeout"></a> alluxio.worker.startup.timeout</td>  <td>10min</td>  <td>Maximum time to wait for worker startup.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.storage.checker.enabled"></a> alluxio.worker.storage.checker.enabled</td>  <td>true</td>  <td>Whether periodic storage health checker is enabled on Alluxio workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.block.lock.readers"></a> alluxio.worker.tieredstore.block.lock.readers</td>  <td>1000</td>  <td>The max number of concurrent readers for a block lock.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.block.locks"></a> alluxio.worker.tieredstore.block.locks</td>  <td>1000</td>  <td>Total number of block locks for an Alluxio block worker. Larger value leads to finer locking granularity, but uses more space.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.free.ahead.bytes"></a> alluxio.worker.tieredstore.free.ahead.bytes</td>  <td>0</td>  <td>Amount to free ahead when worker storage is full. Higher values will help decrease CPU utilization under peak storage. Lower values will increase storage utilization.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level0.alias"></a> alluxio.worker.tieredstore.level0.alias</td>  <td>MEM</td>  <td>The alias of the top storage tier on this worker. It must match one of the global storage tiers from the master configuration. We disable placing an alias lower in the global hierarchy before an alias with a higher position on the worker hierarchy. So by default, SSD cannot come before MEM on any worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level0.dirs.mediumtype"></a> alluxio.worker.tieredstore.level0.dirs.mediumtype</td>  <td>${alluxio.worker.tieredstore.level0.alias}</td>  <td>A comma-separated list of media types (e.g., "MEM,MEM,SSD") for each storage directory on the top storage tier specified by alluxio.worker.tieredstore.level0.dirs.path.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level0.dirs.path"></a> alluxio.worker.tieredstore.level0.dirs.path</td>  <td>/mnt/ramdisk on Linux, /Volumes/ramdisk on OSX</td>  <td>A comma-separated list of paths (eg., /mnt/ramdisk1,/mnt/ramdisk2,/mnt/ssd/alluxio/cache1) of storage directories for the top storage tier. Note that for MacOS, the root directory should be `/Volumes/` and not `/mnt/`.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level0.dirs.quota"></a> alluxio.worker.tieredstore.level0.dirs.quota</td>  <td>${alluxio.worker.ramdisk.size}</td>  <td>A comma-separated list of capacities (e.g., "500MB,500MB,5GB") for each storage directory on the top storage tier specified by alluxio.worker.tieredstore.level0.dirs.path. For any "MEM"-type media (i.e, the ramdisks), this value should be set equivalent to the value specified by alluxio.worker.ramdisk.size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level0.watermark.high.ratio"></a> alluxio.worker.tieredstore.level0.watermark.high.ratio</td>  <td>0.95</td>  <td>The high watermark of the space in the top storage tier (a value between 0 and 1).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level0.watermark.low.ratio"></a> alluxio.worker.tieredstore.level0.watermark.low.ratio</td>  <td>0.7</td>  <td>The low watermark of the space in the top storage tier (a value between 0 and 1).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level1.alias"></a> alluxio.worker.tieredstore.level1.alias</td>  <td></td>  <td>The alias of the second storage tier on this worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level1.dirs.mediumtype"></a> alluxio.worker.tieredstore.level1.dirs.mediumtype</td>  <td>${alluxio.worker.tieredstore.level1.alias}</td>  <td>A list of media types (e.g., "SSD,SSD,HDD") for each storage directory on the second storage tier specified by alluxio.worker.tieredstore.level1.dirs.path.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level1.dirs.path"></a> alluxio.worker.tieredstore.level1.dirs.path</td>  <td></td>  <td>A comma-separated list of paths (eg., /mnt/ssd/alluxio/cache2,/mnt/ssd/alluxio/cache3,/mnt/hdd/alluxio/cache1) of storage directories for the second storage tier.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level1.dirs.quota"></a> alluxio.worker.tieredstore.level1.dirs.quota</td>  <td></td>  <td>A comma-separated list of capacities (e.g., "5GB,5GB,50GB") for each storage directory on the second storage tier specified by alluxio.worker.tieredstore.level1.dirs.path.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level1.watermark.high.ratio"></a> alluxio.worker.tieredstore.level1.watermark.high.ratio</td>  <td>0.95</td>  <td>The high watermark of the space in the second storage tier (a value between 0 and 1).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level1.watermark.low.ratio"></a> alluxio.worker.tieredstore.level1.watermark.low.ratio</td>  <td>0.7</td>  <td>The low watermark of the space in the second storage tier (a value between 0 and 1).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level2.alias"></a> alluxio.worker.tieredstore.level2.alias</td>  <td></td>  <td>The alias of the third storage tier on this worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level2.dirs.mediumtype"></a> alluxio.worker.tieredstore.level2.dirs.mediumtype</td>  <td>${alluxio.worker.tieredstore.level2.alias}</td>  <td>A list of media types (e.g., "SSD,HDD,HDD") for each storage directory on the third storage tier specified by alluxio.worker.tieredstore.level2.dirs.path.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level2.dirs.path"></a> alluxio.worker.tieredstore.level2.dirs.path</td>  <td></td>  <td>A comma-separated list of paths (eg., /mnt/ssd/alluxio/cache4,/mnt/hdd/alluxio/cache2,/mnt/hdd/alluxio/cache3) of storage directories for the third storage tier.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level2.dirs.quota"></a> alluxio.worker.tieredstore.level2.dirs.quota</td>  <td></td>  <td>A comma-separated list of capacities (e.g., "5GB,50GB,50GB") for each storage directory on the third storage tier specified by alluxio.worker.tieredstore.level2.dirs.path.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level2.watermark.high.ratio"></a> alluxio.worker.tieredstore.level2.watermark.high.ratio</td>  <td>0.95</td>  <td>The high watermark of the space in the third storage tier (a value between 0 and 1).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.level2.watermark.low.ratio"></a> alluxio.worker.tieredstore.level2.watermark.low.ratio</td>  <td>0.7</td>  <td>The low watermark of the space in the third storage tier (a value between 0 and 1).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.tieredstore.levels"></a> alluxio.worker.tieredstore.levels</td>  <td>1</td>  <td>The number of storage tiers on the worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.ufs.instream.cache.enabled"></a> alluxio.worker.ufs.instream.cache.enabled</td>  <td>true</td>  <td>Enable caching for seekable under storage input stream, so that subsequent seek operations on the same file will reuse the cached input stream. This will improve position read performance as the open operations of some under file system would be expensive. The cached input stream would be stale, when the UFS file is modified without notifying alluxio. </td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.ufs.instream.cache.expiration.time"></a> alluxio.worker.ufs.instream.cache.expiration.time</td>  <td>5min</td>  <td>Cached UFS instream expiration time.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.ufs.instream.cache.max.size"></a> alluxio.worker.ufs.instream.cache.max.size</td>  <td>5000</td>  <td>The max entries in the UFS instream cache.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.web.bind.host"></a> alluxio.worker.web.bind.host</td>  <td>0.0.0.0</td>  <td>The hostname Alluxio worker's web server binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.web.hostname"></a> alluxio.worker.web.hostname</td>  <td></td>  <td>The hostname Alluxio worker's web UI binds to.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.web.port"></a> alluxio.worker.web.port</td>  <td>30000</td>  <td>The port Alluxio worker's web UI runs on.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.worker.whitelist"></a> alluxio.worker.whitelist</td>  <td>/</td>  <td>A comma-separated list of prefixes of the paths which are cacheable, separated by semi-colons. Alluxio will try to cache the cacheable file when it is read for the first time.</td></tr>

</tbody></table>

## User Configuration

The user configuration specifies values regarding file system access.

<table class="table table-striped">
<tbody><tr><th>Property Name</th><th>Default</th><th>Description</th></tr>
<tr>  <td><a class="anchor" name="alluxio.user.app.id"></a> alluxio.user.app.id</td>  <td></td>  <td>The custom id to use for labeling this client's info, such as metrics. If unset, a random long will be used. This value is displayed in the client logs on initialization. Note that using the same app id will cause client info to be aggregated, so different applications must set their own ids or leave this value unset to use a randomly generated id.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.avoid.eviction.policy.reserved.size.bytes"></a> alluxio.user.block.avoid.eviction.policy.reserved.size.bytes</td>  <td>0MB</td>  <td>The portion of space reserved in a worker when using the LocalFirstAvoidEvictionPolicy class as block location policy.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.master.client.pool.gc.interval"></a> alluxio.user.block.master.client.pool.gc.interval</td>  <td>120sec</td>  <td>The interval at which block master client GC checks occur.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.master.client.pool.gc.threshold"></a> alluxio.user.block.master.client.pool.gc.threshold</td>  <td>120sec</td>  <td>A block master client is closed if it has been idle for more than this threshold.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.master.client.pool.size.max"></a> alluxio.user.block.master.client.pool.size.max</td>  <td>500</td>  <td>The maximum number of block master clients cached in the block master client pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.master.client.pool.size.min"></a> alluxio.user.block.master.client.pool.size.min</td>  <td>0</td>  <td>The minimum number of block master clients cached in the block master client pool. For long running processes, this should be set to zero.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.read.metrics.enabled"></a> alluxio.user.block.read.metrics.enabled</td>  <td>false</td>  <td>Whether detailed block read metrics will be recorded and sink.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.read.retry.max.duration"></a> alluxio.user.block.read.retry.max.duration</td>  <td>5min</td>  <td>This duration controls for how long Alluxio clients should tryreading a single block. If a particular block can't be read within this duration, then the I/O will timeout.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.read.retry.sleep.base"></a> alluxio.user.block.read.retry.sleep.base</td>  <td>250ms</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.read.retry.sleep.max"></a> alluxio.user.block.read.retry.sleep.max</td>  <td>2sec</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.size.bytes.default"></a> alluxio.user.block.size.bytes.default</td>  <td>64MB</td>  <td>Default block size for Alluxio files.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.worker.client.pool.gc.threshold"></a> alluxio.user.block.worker.client.pool.gc.threshold</td>  <td>300sec</td>  <td>A block worker client is closed if it has been idle for more than this threshold.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.worker.client.pool.max"></a> alluxio.user.block.worker.client.pool.max</td>  <td>1024</td>  <td>The maximum number of block worker clients cached in the block worker client pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.block.write.location.policy.class"></a> alluxio.user.block.write.location.policy.class</td>  <td>alluxio.client.block.policy.LocalFirstPolicy</td>  <td>The default location policy for choosing workers for writing a file's blocks.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.async.restore.enabled"></a> alluxio.user.client.cache.async.restore.enabled</td>  <td>true</td>  <td>If this is enabled, cache restore state asynchronously.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.async.write.enabled"></a> alluxio.user.client.cache.async.write.enabled</td>  <td>false</td>  <td>If this is enabled, cache data asynchronously.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.async.write.threads"></a> alluxio.user.client.cache.async.write.threads</td>  <td>16</td>  <td>Number of threads to asynchronously cache data.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.dirs"></a> alluxio.user.client.cache.dirs</td>  <td>/tmp/alluxio_cache</td>  <td>A list of the directories where client-side cache is stored.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.enabled"></a> alluxio.user.client.cache.enabled</td>  <td>false</td>  <td>If this is enabled, data will be cached on Alluxio client.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.eviction.retries"></a> alluxio.user.client.cache.eviction.retries</td>  <td>10</td>  <td>Max number of eviction retries.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.evictor.class"></a> alluxio.user.client.cache.evictor.class</td>  <td>alluxio.client.file.cache.evictor.LRUCacheEvictor</td>  <td>The strategy that client uses to evict local cached pages when running out of space. Currently valid options include `alluxio.client.file.cache.evictor.LRUCacheEvictor`,`alluxio.client.file.cache.evictor.LFUCacheEvictor`.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.evictor.lfu.logbase"></a> alluxio.user.client.cache.evictor.lfu.logbase</td>  <td>2.0</td>  <td>The log base for client cache LFU evictor bucket index.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.evictor.nondeterministic.enabled"></a> alluxio.user.client.cache.evictor.nondeterministic.enabled</td>  <td>false</td>  <td>If this is enabled, the evictor picks uniformly from the worst k elements.Currently only LRU is supported.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.filter.class"></a> alluxio.user.client.cache.filter.class</td>  <td>alluxio.client.file.cache.filter.DefaultCacheFilter</td>  <td>The default cache filter caches everything</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.filter.config-file"></a> alluxio.user.client.cache.filter.config-file</td>  <td>${alluxio.conf.dir}/cache_filter.properties</td>  <td>The alluxio cache filter config file</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.instream_buffer_size"></a> alluxio.user.client.cache.instream_buffer_size</td>  <td>0B</td>  <td>Size of the reading buffer for tiny read.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.local.store.file.buckets"></a> alluxio.user.client.cache.local.store.file.buckets</td>  <td>1000</td>  <td>The number of file buckets for the local page store of the client-side cache. It is recommended to set this to a high value if the number of unique files is expected to be high (# files / file buckets &lt;= 100,000).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.page.size"></a> alluxio.user.client.cache.page.size</td>  <td>1MB</td>  <td>Size of each page in client-side cache.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.quota.enabled"></a> alluxio.user.client.cache.quota.enabled</td>  <td>false</td>  <td>Whether to support cache quota.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.bloomfilter.num"></a> alluxio.user.client.cache.shadow.bloomfilter.num</td>  <td>4</td>  <td>The number of bloom filters used for tracking. Each tracks a segment of window</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.cuckoo.clock.bits"></a> alluxio.user.client.cache.shadow.cuckoo.clock.bits</td>  <td>6</td>  <td>The number of bits of each item's clock field.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.cuckoo.scope.bits"></a> alluxio.user.client.cache.shadow.cuckoo.scope.bits</td>  <td>8</td>  <td>The number of bits of each item's scope field.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.cuckoo.size.bits"></a> alluxio.user.client.cache.shadow.cuckoo.size.bits</td>  <td>20</td>  <td>The number of bits of each item's size field.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.cuckoo.size.encoder.enabled"></a> alluxio.user.client.cache.shadow.cuckoo.size.encoder.enabled</td>  <td>false</td>  <td>The flag to enable the size encoder for cuckoo filter.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.cuckoo.size.prefix.bits"></a> alluxio.user.client.cache.shadow.cuckoo.size.prefix.bits</td>  <td>8</td>  <td>The prefix bits length of the size field.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.cuckoo.size.suffix.bits"></a> alluxio.user.client.cache.shadow.cuckoo.size.suffix.bits</td>  <td>12</td>  <td>The suffix bits length of the size field.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.enabled"></a> alluxio.user.client.cache.shadow.enabled</td>  <td>false</td>  <td>If this is enabled, a shadow cache will be created to tracking the working set of a past time window, and measure the hit ratio if the working set fits the cache</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.memory.overhead"></a> alluxio.user.client.cache.shadow.memory.overhead</td>  <td>125MB</td>  <td>The total memory overhead for bloom filters used for tracking</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.type"></a> alluxio.user.client.cache.shadow.type</td>  <td>CLOCK_CUCKOO_FILTER</td>  <td>The type of shadow cache to be used. Valid options are `MULTIPLE_BLOOM_FILTER` (which uses a chain of bloom filters), `CLOCK_CUCKOO_FILTER` (which uses cuckoo filter with extended field).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.shadow.window"></a> alluxio.user.client.cache.shadow.window</td>  <td>24h</td>  <td>The past time window for the shadow cache to tracking the working set, and it is in the unit of second</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.size"></a> alluxio.user.client.cache.size</td>  <td>512MB</td>  <td>A list of maximum cache size for each cache directory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.store.overhead"></a> alluxio.user.client.cache.store.overhead</td>  <td></td>  <td>A fraction value representing the storage overhead writing to disk. For example, with 1GB allocated cache space, and 10% storage overhead we expect no more than 1024MB / (1 + 10%) user data to store.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.store.type"></a> alluxio.user.client.cache.store.type</td>  <td>LOCAL</td>  <td>The type of page store to use for client-side cache. Can be either `LOCAL` or `ROCKS`. The `LOCAL` page store stores all pages in a directory, the `ROCKS` page store utilizes rocksDB to persist the data.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.timeout.duration"></a> alluxio.user.client.cache.timeout.duration</td>  <td>-1</td>  <td>The timeout duration for local cache I/O operations (reading/writing/deleting). When this property is a positive value,local cache operations after timing out will fail and fallback to external file system but transparent to applications; when this property is a negative value, this feature is disabled.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.timeout.threads"></a> alluxio.user.client.cache.timeout.threads</td>  <td>32</td>  <td>The number of threads to handle cache I/O operation timeout, when alluxio.user.client.cache.timeout.duration is positive.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.ttl.check.interval.seconds"></a> alluxio.user.client.cache.ttl.check.interval.seconds</td>  <td>3600</td>  <td>TTL check interval time in seconds.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.ttl.enabled"></a> alluxio.user.client.cache.ttl.enabled</td>  <td>false</td>  <td>Whether to support cache quota.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.cache.ttl.threshold.seconds"></a> alluxio.user.client.cache.ttl.threshold.seconds</td>  <td>10800</td>  <td>TTL threshold time in seconds.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.client.report.version.enabled"></a> alluxio.user.client.report.version.enabled</td>  <td>false</td>  <td>Whether the client reports version information to the server.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.conf.cluster.default.enabled"></a> alluxio.user.conf.cluster.default.enabled</td>  <td>true</td>  <td>When this property is true, an Alluxio client will load the default values of cluster-wide configuration and path-specific configuration set by Alluxio master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.conf.sync.interval"></a> alluxio.user.conf.sync.interval</td>  <td>1min</td>  <td>The time period of client master heartbeat to update the configuration if necessary from meta master.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.date.format.pattern"></a> alluxio.user.date.format.pattern</td>  <td>MM-dd-yyyy HH:mm:ss:SSS</td>  <td>Display formatted date in cli command and web UI by given date format pattern.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.buffer.bytes"></a> alluxio.user.file.buffer.bytes</td>  <td>8MB</td>  <td>The size of the file buffer to use for file system reads/writes.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.copyfromlocal.block.location.policy.class"></a> alluxio.user.file.copyfromlocal.block.location.policy.class</td>  <td>alluxio.client.block.policy.RoundRobinPolicy</td>  <td>The default location policy for choosing workers for writing a file's blocks using copyFromLocal command.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.create.ttl"></a> alluxio.user.file.create.ttl</td>  <td>-1</td>  <td>Time to live for files created by a user, no ttl by default.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.create.ttl.action"></a> alluxio.user.file.create.ttl.action</td>  <td>FREE</td>  <td>When file's ttl is expired, the action performs on it. Options: FREE(default), DELETE_ALLUXIO or DELETE</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.delete.unchecked"></a> alluxio.user.file.delete.unchecked</td>  <td>false</td>  <td>Whether to check if the UFS contents are in sync with Alluxio before attempting to delete persisted directories recursively.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.include.operation.id"></a> alluxio.user.file.include.operation.id</td>  <td>true</td>  <td>Whether to send a unique operation id with designated filesystem operations.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.master.client.pool.gc.interval"></a> alluxio.user.file.master.client.pool.gc.interval</td>  <td>120sec</td>  <td>The interval at which file system master client GC checks occur.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.master.client.pool.gc.threshold"></a> alluxio.user.file.master.client.pool.gc.threshold</td>  <td>120sec</td>  <td>A fs master client is closed if it has been idle for more than this threshold.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.master.client.pool.size.max"></a> alluxio.user.file.master.client.pool.size.max</td>  <td>500</td>  <td>The maximum number of fs master clients cached in the fs master client pool.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.master.client.pool.size.min"></a> alluxio.user.file.master.client.pool.size.min</td>  <td>0</td>  <td>The minimum number of fs master clients cached in the fs master client pool. For long running processes, this should be set to zero.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.metadata.load.type"></a> alluxio.user.file.metadata.load.type</td>  <td>ONCE</td>  <td>The behavior of loading metadata from UFS. When information about a path is requested and the path does not exist in Alluxio, metadata can be loaded from the UFS. Valid options are `ALWAYS`, `NEVER`, and `ONCE`. `ALWAYS` will always access UFS to see if the path exists in the UFS. `NEVER` will never consult the UFS. `ONCE` will access the UFS the "first" time (according to a cache), but not after that. This parameter is ignored if a metadata sync is performed, via the parameter "alluxio.user.file.metadata.sync.interval"</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.metadata.sync.interval"></a> alluxio.user.file.metadata.sync.interval</td>  <td>-1</td>  <td>The interval for syncing UFS metadata before invoking an operation on a path. -1 means no sync will occur. 0 means Alluxio will always sync the metadata of the path before an operation. If you specify a time interval, Alluxio will (best effort) not re-sync a path within that time interval. Syncing the metadata for a path must interact with the UFS, so it is an expensive operation. If a sync is performed for an operation, the configuration of "alluxio.user.file.metadata.load.type" will be ignored.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.passive.cache.enabled"></a> alluxio.user.file.passive.cache.enabled</td>  <td>true</td>  <td>Whether to cache files to local Alluxio workers when the files are read from remote workers (not UFS).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.persist.on.rename"></a> alluxio.user.file.persist.on.rename</td>  <td>false</td>  <td>Whether or not to asynchronously persist any files which have been renamed. This is helpful when working with compute frameworks which use rename to commit results.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.persistence.initial.wait.time"></a> alluxio.user.file.persistence.initial.wait.time</td>  <td>0</td>  <td>Time to wait before starting the persistence job. When the value is set to -1, the file will be persisted by rename operation or persist CLI but will not be automatically persisted in other cases. This is to avoid the heavy object copy in rename operation when alluxio.user.file.writetype.default is set to ASYNC_THROUGH. This value should be smaller than the value of alluxio.master.persistence.max.total.wait.time</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.readtype.default"></a> alluxio.user.file.readtype.default</td>  <td>CACHE</td>  <td>Default read type when creating Alluxio files. Valid options are `CACHE_PROMOTE` (move data to highest tier if already in Alluxio storage, write data into highest tier of local Alluxio if data needs to be read from under storage), `CACHE` (write data into highest tier of local Alluxio if data needs to be read from under storage), `NO_CACHE` (no data interaction with Alluxio, if the read is from Alluxio data migration or eviction will not occur).</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.replication.durable"></a> alluxio.user.file.replication.durable</td>  <td>1</td>  <td>The target replication level of a file created by ASYNC_THROUGH writesbefore this file is persisted.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.replication.max"></a> alluxio.user.file.replication.max</td>  <td>-1</td>  <td>The target max replication level of a file in Alluxio space. Setting this property to a negative value means no upper limit.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.replication.min"></a> alluxio.user.file.replication.min</td>  <td>0</td>  <td>The target min replication level of a file in Alluxio space.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.reserved.bytes"></a> alluxio.user.file.reserved.bytes</td>  <td>${alluxio.user.block.size.bytes.default}</td>  <td>The size to reserve on workers for file system writes.Using smaller value will improve concurrency for writes smaller than block size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.sequential.pread.threshold"></a> alluxio.user.file.sequential.pread.threshold</td>  <td>2MB</td>  <td>An upper bound on the client buffer size for positioned read to hint at the sequential nature of reads. For reads with a buffer size greater than this threshold, the read op is treated to be sequential and the worker may handle the read differently. For instance, cold reads from the HDFS ufs may use a different HDFS client API.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.target.media"></a> alluxio.user.file.target.media</td>  <td></td>  <td>Preferred media type while storing file's blocks.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.ufs.tier.enabled"></a> alluxio.user.file.ufs.tier.enabled</td>  <td>false</td>  <td>When workers run out of available memory, whether the client can skip writing data to Alluxio but fallback to write to UFS without stopping the application. This property only works when the write type is ASYNC_THROUGH.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.waitcompleted.poll"></a> alluxio.user.file.waitcompleted.poll</td>  <td>1sec</td>  <td>The time interval to poll a file for its completion status when using waitCompleted.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.write.init.max.duration"></a> alluxio.user.file.write.init.max.duration</td>  <td>2min</td>  <td>Controls how long to retry initialization of a file write, when Alluxio workers are required but not ready.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.write.init.sleep.max"></a> alluxio.user.file.write.init.sleep.max</td>  <td>5sec</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.write.init.sleep.min"></a> alluxio.user.file.write.init.sleep.min</td>  <td>1sec</td>  <td>N/A</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.write.tier.default"></a> alluxio.user.file.write.tier.default</td>  <td>0</td>  <td>The default tier for choosing a where to write a block. Valid option is any integer. Non-negative values identify tiers starting from top going down (0 identifies the first tier, 1 identifies the second tier, and so on). If the provided value is greater than the number of tiers, it identifies the last tier. Negative values identify tiers starting from the bottom going up (-1 identifies the last tier, -2 identifies the second to last tier, and so on). If the absolute value of the provided value is greater than the number of tiers, it identifies the first tier.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.file.writetype.default"></a> alluxio.user.file.writetype.default</td>  <td>ASYNC_THROUGH</td>  <td>Default write type when creating Alluxio files. Valid options are `MUST_CACHE` (write will only go to Alluxio and must be stored in Alluxio), `CACHE_THROUGH` (try to cache, write to UnderFS synchronously), `THROUGH` (no cache, write to UnderFS synchronously), `ASYNC_THROUGH` (write to cache, write to UnderFS asynchronously, replicated alluxio.user.file.replication.durable times in Alluxio before data is persisted.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.hdfs.client.exclude.mount.info.on.list.status"></a> alluxio.user.hdfs.client.exclude.mount.info.on.list.status</td>  <td>false</td>  <td>If enabled, the mount info will be excluded from the response when a HDFS client calls alluxio to list status on a directory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.hostname"></a> alluxio.user.hostname</td>  <td></td>  <td>The hostname to use for an Alluxio client.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.local.reader.chunk.size.bytes"></a> alluxio.user.local.reader.chunk.size.bytes</td>  <td>8MB</td>  <td>When a client reads from a local worker, the maximum data chunk size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.local.writer.chunk.size.bytes"></a> alluxio.user.local.writer.chunk.size.bytes</td>  <td>64KB</td>  <td>When a client writes to a local worker, the maximum data chunk size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.logging.threshold"></a> alluxio.user.logging.threshold</td>  <td>10s</td>  <td>Logging a client RPC when it takes more time than the threshold.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.master.polling.timeout"></a> alluxio.user.master.polling.timeout</td>  <td>30sec</td>  <td>The maximum time for a rpc client to wait for master to respond.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.metadata.cache.enabled"></a> alluxio.user.metadata.cache.enabled</td>  <td>false</td>  <td>If this is enabled, metadata of paths will be cached. The cached metadata will be evicted when it expires after alluxio.user.metadata.cache.expiration.time or the cache size is over the limit of alluxio.user.metadata.cache.max.size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.metadata.cache.expiration.time"></a> alluxio.user.metadata.cache.expiration.time</td>  <td>10min</td>  <td>Metadata will expire and be evicted after being cached for this time period. Only valid if alluxio.user.metadata.cache.enabled is set to true.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.metadata.cache.max.size"></a> alluxio.user.metadata.cache.max.size</td>  <td>100000</td>  <td>Maximum number of paths with cached metadata. Only valid if alluxio.user.metadata.cache.enabled is set to true.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.metrics.collection.enabled"></a> alluxio.user.metrics.collection.enabled</td>  <td>true</td>  <td>Enable collecting the client-side metrics and heartbeat them to master</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.metrics.heartbeat.interval"></a> alluxio.user.metrics.heartbeat.interval</td>  <td>10sec</td>  <td>The time period of client master heartbeat to send the client-side metrics.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.data.timeout"></a> alluxio.user.network.data.timeout</td>  <td></td>  <td>The maximum time for an Alluxio client to wait for a data response (e.g. block reads and block writes) from Alluxio worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.flowcontrol.window"></a> alluxio.user.network.flowcontrol.window</td>  <td></td>  <td>The HTTP2 flow control window used by user gRPC connections. Larger value will allow more data to be buffered but will use more memory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.keepalive.time"></a> alluxio.user.network.keepalive.time</td>  <td></td>  <td>The amount of time for a gRPC client (for block reads and block writes) to wait for a response before pinging the server to see if it is still alive.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.keepalive.timeout"></a> alluxio.user.network.keepalive.timeout</td>  <td></td>  <td>The maximum time for a gRPC client (for block reads and block writes) to wait for a keepalive response before closing the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.max.inbound.message.size"></a> alluxio.user.network.max.inbound.message.size</td>  <td></td>  <td>The max inbound message size used by user gRPC connections.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.netty.channel"></a> alluxio.user.network.netty.channel</td>  <td></td>  <td>Type of netty channels. If EPOLL is not available, this will automatically fall back to NIO.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.netty.worker.threads"></a> alluxio.user.network.netty.worker.threads</td>  <td></td>  <td>How many threads to use for remote block worker client to read from remote block workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.reader.buffer.size.messages"></a> alluxio.user.network.reader.buffer.size.messages</td>  <td></td>  <td>When a client reads from a remote worker, the maximum number of messages to buffer by the client. A message can be either a command response, a data chunk, or a gRPC stream event such as complete or error.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.reader.chunk.size.bytes"></a> alluxio.user.network.reader.chunk.size.bytes</td>  <td></td>  <td>When a client reads from a remote worker, the maximum chunk size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.rpc.flowcontrol.window"></a> alluxio.user.network.rpc.flowcontrol.window</td>  <td>2MB</td>  <td>The HTTP2 flow control window used by user rpc connections. Larger value will allow more data to be buffered but will use more memory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.rpc.keepalive.time"></a> alluxio.user.network.rpc.keepalive.time</td>  <td>30sec</td>  <td>The amount of time for a rpc client to wait for a response before pinging the server to see if it is still alive.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.rpc.keepalive.timeout"></a> alluxio.user.network.rpc.keepalive.timeout</td>  <td>30sec</td>  <td>The maximum time for a rpc client to wait for a keepalive response before closing the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.rpc.max.connections"></a> alluxio.user.network.rpc.max.connections</td>  <td>1</td>  <td>The maximum number of physical connections to be used per target host.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.rpc.max.inbound.message.size"></a> alluxio.user.network.rpc.max.inbound.message.size</td>  <td>100MB</td>  <td>The max inbound message size used by user rpc connections.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.rpc.netty.channel"></a> alluxio.user.network.rpc.netty.channel</td>  <td>EPOLL</td>  <td>Type of netty channels used by rpc connections. If EPOLL is not available, this will automatically fall back to NIO.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.rpc.netty.worker.threads"></a> alluxio.user.network.rpc.netty.worker.threads</td>  <td>0</td>  <td>How many threads to use for rpc client to read from remote workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.streaming.flowcontrol.window"></a> alluxio.user.network.streaming.flowcontrol.window</td>  <td>2MB</td>  <td>The HTTP2 flow control window used by user streaming connections. Larger value will allow more data to be buffered but will use more memory.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.streaming.keepalive.time"></a> alluxio.user.network.streaming.keepalive.time</td>  <td>9223372036854775807</td>  <td>The amount of time for a streaming client to wait for a response before pinging the server to see if it is still alive.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.streaming.keepalive.timeout"></a> alluxio.user.network.streaming.keepalive.timeout</td>  <td>30sec</td>  <td>The maximum time for a streaming client to wait for a keepalive response before closing the connection.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.streaming.max.connections"></a> alluxio.user.network.streaming.max.connections</td>  <td>64</td>  <td>The maximum number of physical connections to be used per target host.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.streaming.max.inbound.message.size"></a> alluxio.user.network.streaming.max.inbound.message.size</td>  <td>100MB</td>  <td>The max inbound message size used by user streaming connections.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.streaming.netty.channel"></a> alluxio.user.network.streaming.netty.channel</td>  <td>EPOLL</td>  <td>Type of netty channels used by streaming connections. If EPOLL is not available, this will automatically fall back to NIO.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.streaming.netty.worker.threads"></a> alluxio.user.network.streaming.netty.worker.threads</td>  <td>0</td>  <td>How many threads to use for streaming client to read from remote workers.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.writer.buffer.size.messages"></a> alluxio.user.network.writer.buffer.size.messages</td>  <td></td>  <td>When a client writes to a remote worker, the maximum number of messages to buffer by the client. A message can be either a command response, a data chunk, or a gRPC stream event such as complete or error.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.writer.chunk.size.bytes"></a> alluxio.user.network.writer.chunk.size.bytes</td>  <td></td>  <td>When a client writes to a remote worker, the maximum chunk size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.writer.close.timeout"></a> alluxio.user.network.writer.close.timeout</td>  <td></td>  <td>The timeout to close a writer client.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.writer.flush.timeout"></a> alluxio.user.network.writer.flush.timeout</td>  <td></td>  <td>The timeout to wait for flush to finish in a data writer.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.network.zerocopy.enabled"></a> alluxio.user.network.zerocopy.enabled</td>  <td></td>  <td>Whether zero copy is enabled on client when processing data streams.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.rpc.retry.base.sleep"></a> alluxio.user.rpc.retry.base.sleep</td>  <td>50ms</td>  <td>Alluxio client RPCs automatically retry for transient errors with an exponential backoff. This property determines the base time in the exponential backoff.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.rpc.retry.max.duration"></a> alluxio.user.rpc.retry.max.duration</td>  <td>2min</td>  <td>Alluxio client RPCs automatically retry for transient errors with an exponential backoff. This property determines the maximum duration to retry for before giving up. Note that, this value is set to 5s for fs and fsadmin CLIs.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.rpc.retry.max.sleep"></a> alluxio.user.rpc.retry.max.sleep</td>  <td>3sec</td>  <td>Alluxio client RPCs automatically retry for transient errors with an exponential backoff. This property determines the maximum wait time in the backoff.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.rpc.shuffle.masters.enabled"></a> alluxio.user.rpc.shuffle.masters.enabled</td>  <td>false</td>  <td>Shuffle the client-side configured master rpc addresses.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.short.circuit.enabled"></a> alluxio.user.short.circuit.enabled</td>  <td>true</td>  <td>The short circuit read/write which allows the clients to read/write data without going through Alluxio workers if the data is local is enabled if set to true.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.short.circuit.preferred"></a> alluxio.user.short.circuit.preferred</td>  <td>false</td>  <td>When short circuit and domain socket both enabled, prefer to use short circuit.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.data.read.timeout"></a> alluxio.user.streaming.data.read.timeout</td>  <td>3m</td>  <td>The maximum time for an Alluxio client to wait for a data response for read requests from Alluxio worker. Keep in mind that some streaming operations may take an unexpectedly long time, such as UFS io. In order to handle occasional slow operations, it is recommended for this parameter to be set to a large value, to avoid spurious timeouts.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.data.write.timeout"></a> alluxio.user.streaming.data.write.timeout</td>  <td>3m</td>  <td>The maximum time for an Alluxio client to wait for when writing 1 chunk for block writes to an Alluxio worker. This value can be tuned to offset instability from the UFS.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.reader.buffer.size.messages"></a> alluxio.user.streaming.reader.buffer.size.messages</td>  <td>16</td>  <td>When a client reads from a remote worker, the maximum number of messages to buffer by the client. A message can be either a command response, a data chunk, or a gRPC stream event such as complete or error.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.reader.chunk.size.bytes"></a> alluxio.user.streaming.reader.chunk.size.bytes</td>  <td>1MB</td>  <td>When a client reads from a remote worker, the maximum chunk size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.reader.close.timeout"></a> alluxio.user.streaming.reader.close.timeout</td>  <td>5s</td>  <td>The timeout to close a grpc streaming reader client. If too long, it may add delays to closing clients. If too short, the client will complete the close() before the server confirms the close()</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.writer.buffer.size.messages"></a> alluxio.user.streaming.writer.buffer.size.messages</td>  <td>16</td>  <td>When a client writes to a remote worker, the maximum number of messages to buffer by the client. A message can be either a command response, a data chunk, or a gRPC stream event such as complete or error.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.writer.chunk.size.bytes"></a> alluxio.user.streaming.writer.chunk.size.bytes</td>  <td>1MB</td>  <td>When a client writes to a remote worker, the maximum chunk size.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.writer.close.timeout"></a> alluxio.user.streaming.writer.close.timeout</td>  <td>30min</td>  <td>The timeout to close a writer client.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.writer.flush.timeout"></a> alluxio.user.streaming.writer.flush.timeout</td>  <td>30min</td>  <td>The timeout to wait for flush to finish in a data writer.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.streaming.zerocopy.enabled"></a> alluxio.user.streaming.zerocopy.enabled</td>  <td>true</td>  <td>Whether zero copy is enabled on client when processing data streams.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.ufs.block.location.all.fallback.enabled"></a> alluxio.user.ufs.block.location.all.fallback.enabled</td>  <td>true</td>  <td>Whether to return all workers as block location if ufs block locations are not co-located with any Alluxio workers or is empty.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.ufs.block.read.concurrency.max"></a> alluxio.user.ufs.block.read.concurrency.max</td>  <td>2147483647</td>  <td>The maximum concurrent readers for one UFS block on one Block Worker.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.ufs.block.read.location.policy"></a> alluxio.user.ufs.block.read.location.policy</td>  <td>alluxio.client.block.policy.LocalFirstPolicy</td>  <td>When an Alluxio client reads a file from the UFS, it delegates the read to an Alluxio worker. The client uses this policy to choose which worker to read through. Built-in choices: [&lt;a href="https://docs.alluxio.io/os/javadoc/edge/alluxio/client/block/policy/CapacityBasedDeterministicHashPolicy.html"&gt;alluxio.client.block.policy.CapacityBasedDeterministicHashPolicy&lt;/a&gt;, &lt;a href="https://docs.alluxio.io/os/javadoc/edge/alluxio/client/block/policy/CapacityBaseRandomPolicy.html"&gt;alluxio.client.block.policy.CapacityBaseRandomPolicy&lt;/a&gt;, &lt;a href="https://docs.alluxio.io/os/javadoc/edge/alluxio/client/block/policy/DeterministicHashPolicy.html"&gt;alluxio.client.block.policy.DeterministicHashPolicy&lt;/a&gt;, &lt;a href="https://docs.alluxio.io/os/javadoc/edge/alluxio/client/block/policy/LocalFirstAvoidEvictionPolicy.html"&gt;alluxio.client.block.policy.LocalFirstAvoidEvictionPolicy&lt;/a&gt;, &lt;a href="https://docs.alluxio.io/os/javadoc/edge/alluxio/client/block/policy/LocalFirstPolicy.html"&gt;alluxio.client.block.policy.LocalFirstPolicy&lt;/a&gt;, &lt;a href="https://docs.alluxio.io/os/javadoc/edge/alluxio/client/block/policy/MostAvailableFirstPolicy.html"&gt;alluxio.client.block.policy.MostAvailableFirstPolicy&lt;/a&gt;, &lt;a href="https://docs.alluxio.io/os/javadoc/edge/alluxio/client/block/policy/RoundRobinPolicy.html"&gt;alluxio.client.block.policy.RoundRobinPolicy&lt;/a&gt;, &lt;a href="https://docs.alluxio.io/os/javadoc/edge/alluxio/client/block/policy/SpecificHostPolicy.html"&gt;alluxio.client.block.policy.SpecificHostPolicy&lt;/a&gt;].</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.ufs.block.read.location.policy.cache.expiration.time"></a> alluxio.user.ufs.block.read.location.policy.cache.expiration.time</td>  <td>10min</td>  <td>Deprecated - When alluxio.user.ufs.block.read.location.policy is set to alluxio.client.block.policy.CapacityBaseRandomPolicy, this specifies cache expire time of block location.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.ufs.block.read.location.policy.cache.size"></a> alluxio.user.ufs.block.read.location.policy.cache.size</td>  <td>10000</td>  <td>Deprecated - When alluxio.user.ufs.block.read.location.policy is set to alluxio.client.block.policy.CapacityBaseRandomPolicy, this specifies cache size of block location.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.ufs.block.read.location.policy.deterministic.hash.shards"></a> alluxio.user.ufs.block.read.location.policy.deterministic.hash.shards</td>  <td>1</td>  <td>When alluxio.user.ufs.block.read.location.policy is set to alluxio.client.block.policy.DeterministicHashPolicy or alluxio.client.block.policy.CapacityBasedDeterministicHashPolicy, this specifies the number of hash shards.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.user.worker.list.refresh.interval"></a> alluxio.user.worker.list.refresh.interval</td>  <td>2min</td>  <td>The interval used to refresh the live worker list on the client</td></tr>

</tbody></table>

## Resource Manager Configuration

When running Alluxio with resource managers like Mesos and YARN, Alluxio has additional configuration options.
<table class="table table-striped">
<tbody><tr><th>Property Name</th><th>Default</th><th>Description</th></tr>
<tr>  <td><a class="anchor" name="alluxio.integration.master.resource.cpu"></a> alluxio.integration.master.resource.cpu</td>  <td>1</td>  <td>The number of CPUs to run an Alluxio master for YARN framework.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.integration.master.resource.mem"></a> alluxio.integration.master.resource.mem</td>  <td>1024MB</td>  <td>The amount of memory to run an Alluxio master for YARN framework.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.integration.worker.resource.cpu"></a> alluxio.integration.worker.resource.cpu</td>  <td>1</td>  <td>The number of CPUs to run an Alluxio worker for YARN framework.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.integration.worker.resource.mem"></a> alluxio.integration.worker.resource.mem</td>  <td>1024MB</td>  <td>The amount of memory to run an Alluxio worker for YARN framework.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.integration.yarn.workers.per.host.max"></a> alluxio.integration.yarn.workers.per.host.max</td>  <td>1</td>  <td>The number of workers to run on an Alluxio host for YARN framework.</td></tr>

</tbody></table>

## Security Configuration

The security configuration specifies information regarding the security features, such as
authentication and file permission. Settings for authentication take effect for master, worker, and
user. Settings for file permission only take effect for master. See
[Security](../security/Security.md)
for more information about security features.

<table class="table table-striped">
<tbody><tr><th>Property Name</th><th>Default</th><th>Description</th></tr>
<tr>  <td><a class="anchor" name="alluxio.security.authentication.custom.provider.class"></a> alluxio.security.authentication.custom.provider.class</td>  <td></td>  <td>The class to provide customized authentication implementation, when alluxio.security.authentication.type is set to CUSTOM. It must implement the interface 'alluxio.security.authentication.AuthenticationProvider'.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.authentication.type"></a> alluxio.security.authentication.type</td>  <td>SIMPLE</td>  <td>The authentication mode. Currently three modes are supported: NOSASL, SIMPLE, CUSTOM. The default value SIMPLE indicates that a simple authentication is enabled. Server trusts whoever the client claims to be.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.authorization.permission.enabled"></a> alluxio.security.authorization.permission.enabled</td>  <td>true</td>  <td>Whether to enable access control based on file permission.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.authorization.permission.supergroup"></a> alluxio.security.authorization.permission.supergroup</td>  <td>supergroup</td>  <td>The super group of Alluxio file system. All users in this group have super permission.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.authorization.permission.umask"></a> alluxio.security.authorization.permission.umask</td>  <td>022</td>  <td>The umask of creating file and directory. The initial creation permission is 777, and the difference between directory and file is 111. So for default umask value 022, the created directory has permission 755 and file has permission 644.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.group.mapping.cache.timeout"></a> alluxio.security.group.mapping.cache.timeout</td>  <td>1min</td>  <td>Time for cached group mapping to expire.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.group.mapping.class"></a> alluxio.security.group.mapping.class</td>  <td>alluxio.security.group.provider.ShellBasedUnixGroupsMapping</td>  <td>The class to provide user-to-groups mapping service. Master could get the various group memberships of a given user.  It must implement the interface 'alluxio.security.group.GroupMappingService'. The default implementation execute the 'groups' shell command to fetch the group memberships of a given user.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.login.impersonation.username"></a> alluxio.security.login.impersonation.username</td>  <td>_HDFS_USER_</td>  <td>When alluxio.security.authentication.type is set to SIMPLE or CUSTOM, user application uses this property to indicate the IMPERSONATED user requesting Alluxio service. If it is not set explicitly, or set to _NONE_, impersonation will not be used. A special value of '_HDFS_USER_' can be specified to impersonate the hadoop client user.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.login.username"></a> alluxio.security.login.username</td>  <td></td>  <td>When alluxio.security.authentication.type is set to SIMPLE or CUSTOM, user application uses this property to indicate the user requesting Alluxio service. If it is not set explicitly, the OS login user will be used.</td></tr>
<tr>  <td><a class="anchor" name="alluxio.security.stale.channel.purge.interval"></a> alluxio.security.stale.channel.purge.interval</td>  <td>3day</td>  <td>Interval for which client channels that have been inactive will be regarded as unauthenticated. Such channels will reauthenticate with their target master upon being used for new RPCs.</td></tr>

</tbody></table>
